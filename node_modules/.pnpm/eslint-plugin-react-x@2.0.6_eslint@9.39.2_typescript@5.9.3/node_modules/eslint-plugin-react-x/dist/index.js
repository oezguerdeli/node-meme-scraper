import { DEFAULT_ESLINT_REACT_SETTINGS, coerceSettings, getConfigAdapters, getDocsUrl, getSettingsFromContext } from "@eslint-react/shared";
import { AST_NODE_TYPES } from "@typescript-eslint/types";
import { ESLintUtils } from "@typescript-eslint/utils";
import { isFalseLiteralType, isTrueLiteralType, isTypeFlagSet, unionConstituents } from "ts-api-utils";
import { P, isMatching, match } from "ts-pattern";
import ts from "typescript";
import * as AST from "@eslint-react/ast";
import { ConstructionDetectionHint, findVariable, getChildScopes, getConstruction, getVariableDefinitionNode } from "@eslint-react/var";
import { ComponentDetectionHint, ComponentFlag, DEFAULT_COMPONENT_DETECTION_HINT, JsxEmit, findParentJsxAttribute, getInstanceId, getJsxAttribute, getJsxAttributeName, getJsxConfigFromAnnotation, getJsxConfigFromContext, getJsxElementType, isAssignmentToThisState, isCaptureOwnerStackCall, isChildrenCount, isChildrenForEach, isChildrenMap, isChildrenOnly, isChildrenToArray, isChildrenToArrayCall, isClassComponent, isCloneElementCall, isComponentDidCatch, isComponentDidMount, isComponentDidUpdate, isComponentNameLoose, isComponentWillMount, isComponentWillReceiveProps, isComponentWillUpdate, isCreateContextCall, isCreateElementCall, isCreateRefCall, isDeclaredInRenderPropLoose, isDirectValueOfRenderPropertyLoose, isForwardRefCall, isGetDerivedStateFromError, isGetDerivedStateFromProps, isInitializedFromReact, isInstanceIdEqual, isJsxFragmentElement, isJsxHostElement, isJsxText, isLazyCall, isReactHookCall, isReactHookName, isRenderMethodLike, isThisSetState, isUnsafeComponentWillMount, isUnsafeComponentWillReceiveProps, isUnsafeComponentWillUpdate, isUseCall, isUseCallbackCall, isUseContextCall, isUseMemoCall, isUseStateCall, useComponentCollector, useComponentCollectorLegacy, useHookCollector } from "@eslint-react/core";
import { report, toRegExp } from "@eslint-react/kit";
import { constFalse, constTrue, flow, getOrElseUpdate, identity, unit } from "@eslint-react/eff";
import { compare } from "compare-versions";
import { camelCase } from "string-ts";
import { getConstrainedTypeAtLocation, isTypeReadonly } from "@typescript-eslint/type-utils";
import { getStaticValue } from "@typescript-eslint/utils/ast-utils";
import { getTypeImmutability, isImmutable, isReadonlyDeep, isReadonlyShallow, isUnknown } from "is-immutable-type";

//#region rolldown:runtime
var __defProp = Object.defineProperty;
var __export = (all) => {
	let target = {};
	for (var name$4 in all) __defProp(target, name$4, {
		get: all[name$4],
		enumerable: true
	});
	return target;
};

//#endregion
//#region src/configs/recommended.ts
var recommended_exports = /* @__PURE__ */ __export({
	name: () => name$3,
	rules: () => rules$2,
	settings: () => settings$2
});
const name$3 = "react-x/recommended";
const rules$2 = {
	"react-x/jsx-no-comment-textnodes": "warn",
	"react-x/jsx-no-duplicate-props": "warn",
	"react-x/jsx-no-iife": "off",
	"react-x/jsx-no-undef": "off",
	"react-x/jsx-shorthand-boolean": "off",
	"react-x/jsx-shorthand-fragment": "off",
	"react-x/jsx-uses-react": "warn",
	"react-x/jsx-uses-vars": "warn",
	"react-x/no-access-state-in-setstate": "error",
	"react-x/no-array-index-key": "warn",
	"react-x/no-children-count": "warn",
	"react-x/no-children-for-each": "warn",
	"react-x/no-children-map": "warn",
	"react-x/no-children-only": "warn",
	"react-x/no-children-prop": "off",
	"react-x/no-children-to-array": "warn",
	"react-x/no-class-component": "off",
	"react-x/no-clone-element": "warn",
	"react-x/no-component-will-mount": "error",
	"react-x/no-component-will-receive-props": "error",
	"react-x/no-component-will-update": "error",
	"react-x/no-context-provider": "warn",
	"react-x/no-create-ref": "error",
	"react-x/no-default-props": "error",
	"react-x/no-direct-mutation-state": "error",
	"react-x/no-duplicate-key": "error",
	"react-x/no-forbidden-props": "off",
	"react-x/no-forward-ref": "warn",
	"react-x/no-implicit-key": "warn",
	"react-x/no-leaked-conditional-rendering": "off",
	"react-x/no-missing-component-display-name": "off",
	"react-x/no-missing-context-display-name": "off",
	"react-x/no-missing-key": "error",
	"react-x/no-misused-capture-owner-stack": "off",
	"react-x/no-nested-component-definitions": "error",
	"react-x/no-nested-lazy-component-declarations": "error",
	"react-x/no-prop-types": "error",
	"react-x/no-redundant-should-component-update": "error",
	"react-x/no-set-state-in-component-did-mount": "warn",
	"react-x/no-set-state-in-component-did-update": "warn",
	"react-x/no-set-state-in-component-will-update": "warn",
	"react-x/no-string-refs": "error",
	"react-x/no-unnecessary-key": "off",
	"react-x/no-unnecessary-use-callback": "off",
	"react-x/no-unnecessary-use-memo": "off",
	"react-x/no-unnecessary-use-prefix": "warn",
	"react-x/no-unsafe-component-will-mount": "warn",
	"react-x/no-unsafe-component-will-receive-props": "warn",
	"react-x/no-unsafe-component-will-update": "warn",
	"react-x/no-unstable-context-value": "warn",
	"react-x/no-unstable-default-props": "warn",
	"react-x/no-unused-class-component-members": "warn",
	"react-x/no-unused-props": "off",
	"react-x/no-unused-state": "warn",
	"react-x/no-use-context": "warn",
	"react-x/no-useless-forward-ref": "warn",
	"react-x/no-useless-fragment": "off",
	"react-x/prefer-destructuring-assignment": "off",
	"react-x/prefer-namespace-import": "off",
	"react-x/prefer-read-only-props": "off",
	"react-x/prefer-use-state-lazy-initialization": "warn"
};
const settings$2 = { "react-x": DEFAULT_ESLINT_REACT_SETTINGS };

//#endregion
//#region src/configs/recommended-typescript.ts
var recommended_typescript_exports = /* @__PURE__ */ __export({
	name: () => name$2,
	rules: () => rules$1,
	settings: () => settings$1
});
const name$2 = "react-x/recommended-typescript";
const rules$1 = {
	...rules$2,
	"react-x/jsx-no-duplicate-props": "off",
	"react-x/jsx-no-undef": "off",
	"react-x/jsx-uses-react": "off",
	"react-x/jsx-uses-vars": "off"
};
const settings$1 = { ...settings$2 };

//#endregion
//#region src/configs/recommended-type-checked.ts
var recommended_type_checked_exports = /* @__PURE__ */ __export({
	name: () => name$1,
	rules: () => rules,
	settings: () => settings
});
const name$1 = "react-x/recommended-type-checked";
const rules = {
	...rules$1,
	"react-x/no-leaked-conditional-rendering": "warn",
	"react-x/no-unused-props": "warn"
};
const settings = { ...settings$1 };

//#endregion
//#region package.json
var name = "eslint-plugin-react-x";
var version = "2.0.6";

//#endregion
//#region src/utils/create-rule.ts
const createRule = ESLintUtils.RuleCreator(getDocsUrl("x"));

//#endregion
//#region src/utils/type-is.ts
/** @internal */
const isAnyType = (type) => isTypeFlagSet(type, ts.TypeFlags.TypeParameter | ts.TypeFlags.Any);
/** @internal */
const isBigIntType = (type) => isTypeFlagSet(type, ts.TypeFlags.BigIntLike);
/** @internal */
const isBooleanType = (type) => isTypeFlagSet(type, ts.TypeFlags.BooleanLike);
/** @internal */
const isEnumType = (type) => isTypeFlagSet(type, ts.TypeFlags.EnumLike);
/** @internal */
const isFalsyBigIntType = (type) => type.isLiteral() && isMatching({ value: { base10Value: "0" } }, type);
/** @internal */
const isFalsyNumberType = (type) => type.isNumberLiteral() && type.value === 0;
/** @internal */
const isFalsyStringType = (type) => type.isStringLiteral() && type.value === "";
/** @internal */
const isNeverType = (type) => isTypeFlagSet(type, ts.TypeFlags.Never);
/** @internal */
const isNullishType = (type) => isTypeFlagSet(type, ts.TypeFlags.Null | ts.TypeFlags.Undefined | ts.TypeFlags.VoidLike);
/** @internal */
const isNumberType = (type) => isTypeFlagSet(type, ts.TypeFlags.NumberLike);
/** @internal */
const isObjectType = (type) => !isTypeFlagSet(type, ts.TypeFlags.Null | ts.TypeFlags.Undefined | ts.TypeFlags.VoidLike | ts.TypeFlags.BooleanLike | ts.TypeFlags.StringLike | ts.TypeFlags.NumberLike | ts.TypeFlags.BigIntLike | ts.TypeFlags.TypeParameter | ts.TypeFlags.Any | ts.TypeFlags.Unknown | ts.TypeFlags.Never);
/** @internal */
const isStringType = (type) => isTypeFlagSet(type, ts.TypeFlags.StringLike);
/** @internal */
const isTruthyBigIntType = (type) => type.isLiteral() && isMatching({ value: { base10Value: P.not("0") } }, type);
/** @internal */
const isTruthyNumberType = (type) => type.isNumberLiteral() && type.value !== 0;
/** @internal */
const isTruthyStringType = (type) => type.isStringLiteral() && type.value !== "";
/** @internal */
const isUnknownType = (type) => isTypeFlagSet(type, ts.TypeFlags.Unknown);

//#endregion
//#region src/utils/type-variant.ts
/**
* Ported from https://github.com/typescript-eslint/typescript-eslint/blob/eb736bbfc22554694400e6a4f97051d845d32e0b/packages/eslint-plugin/src/rules/strict-boolean-expressions.ts#L826 with some enhancements
* Get the variants of an array of types.
* @param types The types to get the variants of
* @returns The variants of the types
* @internal
*/
function getTypeVariants(types) {
	const variants = /* @__PURE__ */ new Set();
	if (types.some(isUnknownType)) {
		variants.add("unknown");
		return variants;
	}
	if (types.some(isNullishType)) variants.add("nullish");
	const booleans = types.filter(isBooleanType);
	const boolean0 = booleans[0];
	if (booleans.length === 1 && boolean0 != null) {
		if (isFalseLiteralType(boolean0)) variants.add("falsy boolean");
		else if (isTrueLiteralType(boolean0)) variants.add("truthy boolean");
	} else if (booleans.length === 2) variants.add("boolean");
	const strings = types.filter(isStringType);
	if (strings.length > 0) {
		const evaluated = match(strings).when((types$1) => types$1.every(isTruthyStringType), () => "truthy string").when((types$1) => types$1.every(isFalsyStringType), () => "falsy string").otherwise(() => "string");
		variants.add(evaluated);
	}
	const bigints = types.filter(isBigIntType);
	if (bigints.length > 0) {
		const evaluated = match(bigints).when((types$1) => types$1.every(isTruthyBigIntType), () => "truthy bigint").when((types$1) => types$1.every(isFalsyBigIntType), () => "falsy bigint").otherwise(() => "bigint");
		variants.add(evaluated);
	}
	const numbers = types.filter(isNumberType);
	if (numbers.length > 0) {
		const evaluated = match(numbers).when((types$1) => types$1.every(isTruthyNumberType), () => "truthy number").when((types$1) => types$1.every(isFalsyNumberType), () => "falsy number").otherwise(() => "number");
		variants.add(evaluated);
	}
	if (types.some(isEnumType)) variants.add("enum");
	if (types.some(isObjectType)) variants.add("object");
	if (types.some(isAnyType)) variants.add("any");
	if (types.some(isNeverType)) variants.add("never");
	return variants;
}

//#endregion
//#region src/rules/jsx-key-before-spread.ts
const RULE_NAME$61 = "jsx-key-before-spread";
const RULE_FEATURES$59 = ["EXP"];
var jsx_key_before_spread_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces that the 'key' prop is placed before the spread prop in JSX elements.",
			[Symbol.for("rule_features")]: RULE_FEATURES$59
		},
		messages: { jsxKeyBeforeSpread: "The 'key' prop must be placed before any spread props." },
		schema: []
	},
	name: RULE_NAME$61,
	create: create$61,
	defaultOptions: []
});
function create$61(context) {
	return { JSXOpeningElement(node) {
		let firstSpreadPropIndex = null;
		for (const [index, prop] of node.attributes.entries()) {
			if (prop.type === AST_NODE_TYPES.JSXSpreadAttribute) {
				firstSpreadPropIndex ??= index;
				continue;
			}
			if (firstSpreadPropIndex == null) continue;
			if (prop.name.name === "key" && index > firstSpreadPropIndex) context.report({
				messageId: "jsxKeyBeforeSpread",
				node: prop
			});
		}
	} };
}

//#endregion
//#region src/rules/jsx-no-comment-textnodes.ts
const RULE_NAME$60 = "jsx-no-comment-textnodes";
const RULE_FEATURES$58 = [];
var jsx_no_comment_textnodes_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents comments from being inserted as text nodes.",
			[Symbol.for("rule_features")]: RULE_FEATURES$58
		},
		messages: { jsxNoCommentTextnodes: "Possible misused comment in text node. Comments inside children section of tag should be placed inside braces." },
		schema: []
	},
	name: RULE_NAME$60,
	create: create$60,
	defaultOptions: []
});
function create$60(context) {
	function hasCommentLike(node) {
		if (AST.isOneOf([AST_NODE_TYPES.JSXAttribute, AST_NODE_TYPES.JSXExpressionContainer])(node.parent)) return false;
		return /^\s*\/(?:\/|\*)/mu.test(context.sourceCode.getText(node));
	}
	const visitorFunction = (node) => {
		if (!AST.isOneOf([AST_NODE_TYPES.JSXElement, AST_NODE_TYPES.JSXFragment])(node.parent)) return;
		if (!hasCommentLike(node)) return;
		context.report({
			messageId: "jsxNoCommentTextnodes",
			node
		});
	};
	return {
		JSXText: visitorFunction,
		Literal: visitorFunction
	};
}

//#endregion
//#region src/rules/jsx-no-duplicate-props.ts
const RULE_NAME$59 = "jsx-no-duplicate-props";
const RULE_FEATURES$57 = [];
var jsx_no_duplicate_props_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow duplicate props in JSX elements.",
			[Symbol.for("rule_features")]: RULE_FEATURES$57
		},
		messages: { jsxNoDuplicateProps: "This JSX property is assigned multiple times." },
		schema: []
	},
	name: RULE_NAME$59,
	create: create$59,
	defaultOptions: []
});
function create$59(context) {
	return { JSXOpeningElement(node) {
		const props = [];
		for (const attr of node.attributes) {
			if (attr.type === AST_NODE_TYPES.JSXSpreadAttribute) continue;
			const name$4 = attr.name.name;
			if (typeof name$4 !== "string") continue;
			if (!props.includes(name$4)) {
				props.push(name$4);
				continue;
			}
			context.report({
				messageId: "jsxNoDuplicateProps",
				node: attr
			});
		}
	} };
}

//#endregion
//#region src/rules/jsx-no-iife.ts
const RULE_NAME$58 = "jsx-no-iife";
const RULE_FEATURES$56 = ["EXP"];
var jsx_no_iife_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallows 'IIFE' in JSX elements.",
			[Symbol.for("rule_features")]: RULE_FEATURES$56
		},
		messages: { jsxNoIife: "Avoid using IIFE in JSX elements." },
		schema: []
	},
	name: RULE_NAME$58,
	create: create$58,
	defaultOptions: []
});
function create$58(context) {
	return {
		"JSXElement :function"(node) {
			if (node.parent.type === AST_NODE_TYPES.CallExpression && node.parent.callee === node) context.report({
				messageId: "jsxNoIife",
				node: node.parent
			});
		},
		"JSXFragment :function"(node) {
			if (node.parent.type === AST_NODE_TYPES.CallExpression && node.parent.callee === node) context.report({
				messageId: "jsxNoIife",
				node: node.parent
			});
		}
	};
}

//#endregion
//#region src/rules/jsx-no-undef.ts
const RULE_NAME$57 = "jsx-no-undef";
const RULE_FEATURES$55 = [];
var jsx_no_undef_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow undefined variables in JSX.",
			[Symbol.for("rule_features")]: RULE_FEATURES$55
		},
		messages: { jsxNoUndef: "JSX variable '{{name}}' is not defined." },
		schema: []
	},
	name: RULE_NAME$57,
	create: create$57,
	defaultOptions: []
});
function create$57(context) {
	return { JSXOpeningElement(node) {
		const name$4 = match(node.name).with({ type: AST_NODE_TYPES.JSXIdentifier }, (n) => n.name).with({
			type: AST_NODE_TYPES.JSXMemberExpression,
			object: { type: AST_NODE_TYPES.JSXIdentifier }
		}, (n) => n.object.name).otherwise(() => null);
		if (name$4 == null) return;
		if (name$4 === "this") return;
		if (/^[a-z]/u.test(name$4)) return;
		if (findVariable(name$4, context.sourceCode.getScope(node)) == null) context.report({
			messageId: "jsxNoUndef",
			node,
			data: { name: name$4 }
		});
	} };
}

//#endregion
//#region src/rules/jsx-shorthand-boolean.ts
const RULE_NAME$56 = "jsx-shorthand-boolean";
const RULE_FEATURES$54 = ["CFG", "FIX"];
const defaultOptions$3 = [1];
const schema$1 = [{
	type: "integer",
	enum: [-1, 1]
}];
var jsx_shorthand_boolean_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces shorthand syntax for boolean attributes.",
			[Symbol.for("rule_features")]: RULE_FEATURES$54
		},
		fixable: "code",
		messages: { jsxShorthandBoolean: "{{message}}" },
		schema: schema$1
	},
	name: RULE_NAME$56,
	create: create$56,
	defaultOptions: defaultOptions$3
});
function create$56(context) {
	const policy = context.options[0] ?? defaultOptions$3[0];
	return { JSXAttribute(node) {
		const { value } = node;
		const propName = getJsxAttributeName(context, node);
		switch (true) {
			case policy === 1 && value?.type === AST_NODE_TYPES.JSXExpressionContainer && value.expression.type === AST_NODE_TYPES.Literal && value.expression.value === true:
				context.report({
					messageId: "jsxShorthandBoolean",
					node,
					data: { message: `Omit attribute value for '${propName}'.` },
					fix: (fixer) => fixer.removeRange([node.name.range[1], value.range[1]])
				});
				break;
			case policy === -1 && value === null:
				context.report({
					messageId: "jsxShorthandBoolean",
					node: node.value ?? node,
					data: { message: `Set attribute value for '${propName}'.` },
					fix: (fixer) => fixer.insertTextAfter(node.name, `={true}`)
				});
				break;
		}
	} };
}

//#endregion
//#region src/rules/jsx-shorthand-fragment.ts
const RULE_NAME$55 = "jsx-shorthand-fragment";
const RULE_FEATURES$53 = ["CFG", "FIX"];
const defaultOptions$2 = [1];
const schema = [{
	type: "integer",
	enum: [-1, 1]
}];
var jsx_shorthand_fragment_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces shorthand syntax for fragments.",
			[Symbol.for("rule_features")]: RULE_FEATURES$53
		},
		fixable: "code",
		messages: { jsxShorthandFragment: "{{message}}" },
		schema
	},
	name: RULE_NAME$55,
	create: create$55,
	defaultOptions: defaultOptions$2
});
function create$55(context) {
	const policy = context.options[0] ?? defaultOptions$2[0];
	const { jsxFragmentFactory } = {
		...getJsxConfigFromContext(context),
		...getJsxConfigFromAnnotation(context)
	};
	return match(policy).with(1, () => ({ JSXElement(node) {
		if (!isJsxFragmentElement(context, node)) return;
		if (node.openingElement.attributes.length > 0) return;
		context.report({
			messageId: "jsxShorthandFragment",
			node,
			data: { message: "Use fragment shorthand syntax instead of 'Fragment' component." },
			fix: (fixer) => {
				const { closingElement, openingElement } = node;
				if (closingElement == null) return [];
				return [fixer.replaceTextRange([openingElement.range[0], openingElement.range[1]], "<>"), fixer.replaceTextRange([closingElement.range[0], closingElement.range[1]], "</>")];
			}
		});
	} })).with(-1, () => ({ JSXFragment(node) {
		context.report({
			messageId: "jsxShorthandFragment",
			node,
			data: { message: "Use 'Fragment' component instead of fragment shorthand syntax." },
			fix: (fixer) => {
				const { closingFragment, openingFragment } = node;
				return [fixer.replaceTextRange([openingFragment.range[0], openingFragment.range[1]], `<${jsxFragmentFactory}>`), fixer.replaceTextRange([closingFragment.range[0], closingFragment.range[1]], `</${jsxFragmentFactory}>`)];
			}
		});
	} })).otherwise(() => ({}));
}

//#endregion
//#region src/rules/jsx-uses-react.ts
const RULE_NAME$54 = "jsx-uses-react";
const RULE_FEATURES$52 = [];
var jsx_uses_react_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Marks React variables as used when JSX is used.",
			[Symbol.for("rule_features")]: RULE_FEATURES$52
		},
		messages: { jsxUsesReact: "Marked {{name}} as used." },
		schema: []
	},
	name: RULE_NAME$54,
	create: create$54,
	defaultOptions: []
});
function create$54(context) {
	const { jsx, jsxFactory, jsxFragmentFactory } = {
		...getJsxConfigFromContext(context),
		...getJsxConfigFromAnnotation(context)
	};
	if (jsx === JsxEmit.ReactJSX || jsx === JsxEmit.ReactJSXDev) return {};
	function handleJsxElement(node) {
		context.sourceCode.markVariableAsUsed(jsxFactory, node);
		debugReport(context, node, jsxFactory);
	}
	function handleJsxFragment(node) {
		context.sourceCode.markVariableAsUsed(jsxFragmentFactory, node);
		debugReport(context, node, jsxFragmentFactory);
	}
	return {
		JSXFragment: handleJsxFragment,
		JSXOpeningElement: handleJsxElement,
		JSXOpeningFragment: handleJsxElement
	};
}
function debugReport(context, node, name$4) {
	if (process.env["ESLINT_REACT_DEBUG"] !== "1") return;
	context.report({
		messageId: "jsxUsesReact",
		node,
		data: { name: name$4 }
	});
}

//#endregion
//#region src/rules/jsx-uses-vars.ts
const RULE_NAME$53 = "jsx-uses-vars";
const RULE_FEATURES$51 = [];
var jsx_uses_vars_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Marks variables used in JSX elements as used.",
			[Symbol.for("rule_features")]: RULE_FEATURES$51
		},
		messages: { jsxUsesVars: "An identifier in JSX is marked as used." },
		schema: []
	},
	name: RULE_NAME$53,
	create: create$53,
	defaultOptions: []
});
function create$53(context) {
	return { JSXOpeningElement(node) {
		switch (node.name.type) {
			case AST_NODE_TYPES.JSXIdentifier:
				if (/^[a-z]/u.test(node.name.name)) return;
				context.sourceCode.markVariableAsUsed(node.name.name, node);
				break;
			case AST_NODE_TYPES.JSXMemberExpression: {
				const { object } = node.name;
				if (object.type === AST_NODE_TYPES.JSXIdentifier) context.sourceCode.markVariableAsUsed(object.name, node);
				break;
			}
		}
	} };
}

//#endregion
//#region src/rules/no-access-state-in-setstate.ts
const RULE_NAME$52 = "no-access-state-in-setstate";
const RULE_FEATURES$50 = [];
function isKeyLiteral$2(node, key) {
	return match(key).with({ type: AST_NODE_TYPES.Literal }, constTrue).with({
		type: AST_NODE_TYPES.TemplateLiteral,
		expressions: []
	}, constTrue).with({ type: AST_NODE_TYPES.Identifier }, () => !node.computed).otherwise(constFalse);
}
var no_access_state_in_setstate_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow accessing `this.state` inside `setState` calls.",
			[Symbol.for("rule_features")]: RULE_FEATURES$50
		},
		messages: { noAccessStateInSetstate: "Do not access 'this.state' within 'setState'. Use the update function instead." },
		schema: []
	},
	name: RULE_NAME$52,
	create: create$52,
	defaultOptions: []
});
function create$52(context) {
	if (!context.sourceCode.text.includes("setState")) return {};
	const classStack = [];
	const methodStack = [];
	const setStateStack = [];
	return {
		CallExpression(node) {
			if (!isThisSetState(node)) return;
			setStateStack.push([node, false]);
		},
		"CallExpression:exit"(node) {
			if (!isThisSetState(node)) return;
			setStateStack.pop();
		},
		ClassDeclaration(node) {
			classStack.push([node, isClassComponent(node)]);
		},
		"ClassDeclaration:exit"() {
			classStack.pop();
		},
		ClassExpression(node) {
			classStack.push([node, isClassComponent(node)]);
		},
		"ClassExpression:exit"() {
			classStack.pop();
		},
		MemberExpression(node) {
			if (!AST.isThisExpression(node.object)) return;
			const [currClass, isComponent = false] = classStack.at(-1) ?? [];
			if (currClass == null || !isComponent) return;
			const [currMethod, isStatic = false] = methodStack.at(-1) ?? [];
			if (currMethod == null || isStatic) return;
			const [setState, hasThisState = false] = setStateStack.at(-1) ?? [];
			if (setState == null || hasThisState) return;
			if (AST.getPropertyName(node.property) !== "state") return;
			context.report({
				messageId: "noAccessStateInSetstate",
				node
			});
		},
		MethodDefinition(node) {
			methodStack.push([node, node.static]);
		},
		"MethodDefinition:exit"() {
			methodStack.pop();
		},
		PropertyDefinition(node) {
			methodStack.push([node, node.static]);
		},
		"PropertyDefinition:exit"() {
			methodStack.pop();
		},
		VariableDeclarator(node) {
			const [currClass, isComponent = false] = classStack.at(-1) ?? [];
			if (currClass == null || !isComponent) return;
			const [currMethod, isStatic = false] = methodStack.at(-1) ?? [];
			if (currMethod == null || isStatic) return;
			const [setState, hasThisState = false] = setStateStack.at(-1) ?? [];
			if (setState == null || hasThisState) return;
			if (node.init == null || !AST.isThisExpression(node.init) || node.id.type !== AST_NODE_TYPES.ObjectPattern) return;
			if (!node.id.properties.some((prop) => prop.type === AST_NODE_TYPES.Property && isKeyLiteral$2(prop, prop.key) && AST.getPropertyName(prop.key) === "state")) return;
			context.report({
				messageId: "noAccessStateInSetstate",
				node
			});
		}
	};
}

//#endregion
//#region src/rules/no-array-index-key.ts
const RULE_NAME$51 = "no-array-index-key";
const RULE_FEATURES$49 = [];
const REACT_CHILDREN_METHOD = ["forEach", "map"];
function isReactChildrenMethod(name$4) {
	return REACT_CHILDREN_METHOD.includes(name$4);
}
function isUsingReactChildren(context, node) {
	const { importSource = "react" } = coerceSettings(context.settings);
	const { callee } = node;
	if (!("property" in callee) || !("object" in callee) || !("name" in callee.property)) return false;
	if (!isReactChildrenMethod(callee.property.name)) return false;
	const initialScope = context.sourceCode.getScope(node);
	if (callee.object.type === AST_NODE_TYPES.Identifier && callee.object.name === "Children") return true;
	if (callee.object.type === AST_NODE_TYPES.MemberExpression && "name" in callee.object.object) return isInitializedFromReact(callee.object.object.name, importSource, initialScope);
	return false;
}
function getMapIndexParamName(context, node) {
	const { callee } = node;
	if (callee.type !== AST_NODE_TYPES.MemberExpression) return unit;
	if (callee.property.type !== AST_NODE_TYPES.Identifier) return unit;
	const { name: name$4 } = callee.property;
	const indexPosition = AST.getArrayMethodCallbackIndexParamPosition(name$4);
	if (indexPosition === -1) return unit;
	const callbackArg = node.arguments[isUsingReactChildren(context, node) ? 1 : 0];
	if (callbackArg == null) return unit;
	if (!AST.isOneOf([AST_NODE_TYPES.ArrowFunctionExpression, AST_NODE_TYPES.FunctionExpression])(callbackArg)) return unit;
	const { params } = callbackArg;
	if (params.length < indexPosition + 1) return unit;
	const param = params.at(indexPosition);
	return param != null && "name" in param ? param.name : unit;
}
function getIdentifiersFromBinaryExpression(side) {
	if (side.type === AST_NODE_TYPES.Identifier) return [side];
	if (side.type === AST_NODE_TYPES.BinaryExpression) return [...getIdentifiersFromBinaryExpression(side.left), ...getIdentifiersFromBinaryExpression(side.right)];
	return [];
}
var no_array_index_key_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow an item's index in the array as its key.",
			[Symbol.for("rule_features")]: RULE_FEATURES$49
		},
		messages: { noArrayIndexKey: "Do not use item index in the array as its key." },
		schema: []
	},
	name: RULE_NAME$51,
	create: create$51,
	defaultOptions: []
});
function create$51(context) {
	const indexParamNames = [];
	function isArrayIndex(node) {
		return node.type === AST_NODE_TYPES.Identifier && indexParamNames.some((name$4) => name$4 != null && name$4 === node.name);
	}
	function isCreateOrCloneElementCall(node) {
		return isCreateElementCall(context, node) || isCloneElementCall(context, node);
	}
	function getReportDescriptors(node) {
		switch (node.type) {
			case AST_NODE_TYPES.Identifier:
				if (indexParamNames.some((name$4) => name$4 != null && name$4 === node.name)) return [{
					messageId: "noArrayIndexKey",
					node
				}];
				return [];
			case AST_NODE_TYPES.TemplateLiteral:
			case AST_NODE_TYPES.BinaryExpression: {
				const descriptors = [];
				const expressions = node.type === AST_NODE_TYPES.TemplateLiteral ? node.expressions : getIdentifiersFromBinaryExpression(node);
				for (const expression of expressions) if (isArrayIndex(expression)) descriptors.push({
					messageId: "noArrayIndexKey",
					node: expression
				});
				return descriptors;
			}
			case AST_NODE_TYPES.CallExpression: switch (true) {
				case node.callee.type === AST_NODE_TYPES.MemberExpression && node.callee.property.type === AST_NODE_TYPES.Identifier && node.callee.property.name === "toString" && isArrayIndex(node.callee.object): return [{
					messageId: "noArrayIndexKey",
					node: node.callee.object
				}];
				case node.callee.type === AST_NODE_TYPES.Identifier && node.callee.name === "String" && node.arguments[0] != null && isArrayIndex(node.arguments[0]): return [{
					messageId: "noArrayIndexKey",
					node: node.arguments[0]
				}];
			}
		}
		return [];
	}
	return {
		CallExpression(node) {
			indexParamNames.push(getMapIndexParamName(context, node));
			if (node.arguments.length === 0) return;
			if (!isCreateOrCloneElementCall(node)) return;
			const [, props] = node.arguments;
			if (props?.type !== AST_NODE_TYPES.ObjectExpression) return;
			for (const prop of props.properties) {
				if (!isMatching({ key: { name: "key" } })(prop)) continue;
				if (!("value" in prop)) continue;
				for (const descriptor of getReportDescriptors(prop.value)) report(context)(descriptor);
			}
		},
		"CallExpression:exit"() {
			indexParamNames.pop();
		},
		JSXAttribute(node) {
			if (node.name.name !== "key") return;
			if (indexParamNames.length === 0) return;
			if (node.value?.type !== AST_NODE_TYPES.JSXExpressionContainer) return;
			for (const descriptor of getReportDescriptors(node.value.expression)) report(context)(descriptor);
		}
	};
}

//#endregion
//#region src/rules/no-children-count.ts
const RULE_NAME$50 = "no-children-count";
const RULE_FEATURES$48 = [];
var no_children_count_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow `Children.count`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$48
		},
		messages: { noChildrenCount: "Using 'Children.count' is uncommon and can lead to fragile code. Use alternatives instead." },
		schema: []
	},
	name: RULE_NAME$50,
	create: create$50,
	defaultOptions: []
});
function create$50(context) {
	return { MemberExpression(node) {
		if (isChildrenCount(context, node)) context.report({
			messageId: "noChildrenCount",
			node: node.property
		});
	} };
}

//#endregion
//#region src/rules/no-children-for-each.ts
const RULE_NAME$49 = "no-children-for-each";
const RULE_FEATURES$47 = [];
var no_children_for_each_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow 'Children.forEach'.",
			[Symbol.for("rule_features")]: RULE_FEATURES$47
		},
		messages: { noChildrenForEach: "Using 'Children.forEach' is uncommon and can lead to fragile code. Use alternatives instead." },
		schema: []
	},
	name: RULE_NAME$49,
	create: create$49,
	defaultOptions: []
});
function create$49(context) {
	return { MemberExpression(node) {
		if (isChildrenForEach(context, node)) context.report({
			messageId: "noChildrenForEach",
			node: node.property
		});
	} };
}

//#endregion
//#region src/rules/no-children-map.ts
const RULE_NAME$48 = "no-children-map";
const RULE_FEATURES$46 = [];
var no_children_map_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow `Children.map`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$46
		},
		messages: { noChildrenMap: "Using 'Children.map' is uncommon and can lead to fragile code. Use alternatives instead." },
		schema: []
	},
	name: RULE_NAME$48,
	create: create$48,
	defaultOptions: []
});
function create$48(context) {
	return { MemberExpression(node) {
		if (isChildrenMap(context, node)) context.report({
			messageId: "noChildrenMap",
			node: node.property
		});
	} };
}

//#endregion
//#region src/rules/no-children-only.ts
const RULE_NAME$47 = "no-children-only";
const RULE_FEATURES$45 = [];
var no_children_only_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow `Children.only`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$45
		},
		messages: { noChildrenOnly: "Using 'Children.only' is uncommon and can lead to fragile code. Use alternatives instead." },
		schema: []
	},
	name: RULE_NAME$47,
	create: create$47,
	defaultOptions: []
});
function create$47(context) {
	return { MemberExpression(node) {
		if (isChildrenOnly(context, node)) context.report({
			messageId: "noChildrenOnly",
			node: node.property
		});
	} };
}

//#endregion
//#region src/rules/no-children-prop.ts
const RULE_NAME$46 = "no-children-prop";
const RULE_FEATURES$44 = [];
var no_children_prop_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow passing `children` as a prop.",
			[Symbol.for("rule_features")]: RULE_FEATURES$44
		},
		messages: { noChildrenProp: "Do not pass 'children' as props." },
		schema: []
	},
	name: RULE_NAME$46,
	create: create$46,
	defaultOptions: []
});
function create$46(context) {
	return { JSXElement(node) {
		const childrenProp = getJsxAttribute(context, node)("children");
		if (childrenProp != null) context.report({
			messageId: "noChildrenProp",
			node: childrenProp
		});
	} };
}

//#endregion
//#region src/rules/no-children-to-array.ts
const RULE_NAME$45 = "no-children-to-array";
const RULE_FEATURES$43 = [];
var no_children_to_array_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow `Children.toArray`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$43
		},
		messages: { noChildrenToArray: "Using 'Children.toArray' is uncommon and can lead to fragile code. Use alternatives instead." },
		schema: []
	},
	name: RULE_NAME$45,
	create: create$45,
	defaultOptions: []
});
function create$45(context) {
	return { MemberExpression(node) {
		if (isChildrenToArray(context, node)) context.report({
			messageId: "noChildrenToArray",
			node: node.property
		});
	} };
}

//#endregion
//#region src/rules/no-class-component.ts
const RULE_NAME$44 = "no-class-component";
const RULE_FEATURES$42 = [];
var no_class_component_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow class components except for error boundaries.",
			[Symbol.for("rule_features")]: RULE_FEATURES$42
		},
		messages: { noClassComponent: "Avoid using class components. Use function components instead." },
		schema: []
	},
	name: RULE_NAME$44,
	create: create$44,
	defaultOptions: []
});
function create$44(context) {
	if (!context.sourceCode.text.includes("Component")) return {};
	const { ctx, listeners } = useComponentCollectorLegacy();
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const { name: name$4 = "anonymous", node: component } of components.values()) {
				if (component.body.body.some((m) => isComponentDidCatch(m) || isGetDerivedStateFromError(m))) continue;
				context.report({
					messageId: "noClassComponent",
					node: component,
					data: { name: name$4 }
				});
			}
		}
	};
}

//#endregion
//#region src/rules/no-clone-element.ts
const RULE_NAME$43 = "no-clone-element";
const RULE_FEATURES$41 = [];
var no_clone_element_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow `cloneElement`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$41
		},
		messages: { noCloneElement: "Using 'cloneElement' is uncommon and can lead to fragile code. Use alternatives instead." },
		schema: []
	},
	name: RULE_NAME$43,
	create: create$43,
	defaultOptions: []
});
function create$43(context) {
	return { CallExpression(node) {
		if (isCloneElementCall(context, node)) context.report({
			messageId: "noCloneElement",
			node
		});
	} };
}

//#endregion
//#region src/rules/no-component-will-mount.ts
const RULE_NAME$42 = "no-component-will-mount";
const RULE_FEATURES$40 = ["MOD"];
var no_component_will_mount_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Replace usages of `componentWillMount` with `UNSAFE_componentWillMount`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$40
		},
		fixable: "code",
		messages: { noComponentWillMount: "[Deprecated] Use 'UNSAFE_componentWillMount' instead." },
		schema: []
	},
	name: RULE_NAME$42,
	create: create$42,
	defaultOptions: []
});
function create$42(context) {
	if (!context.sourceCode.text.includes("componentWillMount")) return {};
	const { ctx, listeners } = useComponentCollectorLegacy();
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const { node: component } of components.values()) {
				const { body } = component.body;
				for (const member of body) if (isComponentWillMount(member)) context.report({
					messageId: "noComponentWillMount",
					node: member,
					fix(fixer) {
						if (!("key" in member)) return null;
						return fixer.replaceText(member.key, "UNSAFE_componentWillMount");
					}
				});
			}
		}
	};
}

//#endregion
//#region src/rules/no-component-will-receive-props.ts
const RULE_NAME$41 = "no-component-will-receive-props";
const RULE_FEATURES$39 = ["MOD"];
var no_component_will_receive_props_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Replace usages of `componentWillReceiveProps` with `UNSAFE_componentWillReceiveProps`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$39
		},
		fixable: "code",
		messages: { noComponentWillReceiveProps: "[Deprecated] Use 'UNSAFE_componentWillReceiveProps' instead." },
		schema: []
	},
	name: RULE_NAME$41,
	create: create$41,
	defaultOptions: []
});
function create$41(context) {
	if (!context.sourceCode.text.includes("componentWillReceiveProps")) return {};
	const { ctx, listeners } = useComponentCollectorLegacy();
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const { node: component } of components.values()) {
				const { body } = component.body;
				for (const member of body) if (isComponentWillReceiveProps(member)) context.report({
					messageId: "noComponentWillReceiveProps",
					node: member,
					fix(fixer) {
						if (!("key" in member)) return null;
						return fixer.replaceText(member.key, "UNSAFE_componentWillReceiveProps");
					}
				});
			}
		}
	};
}

//#endregion
//#region src/rules/no-component-will-update.ts
const RULE_NAME$40 = "no-component-will-update";
const RULE_FEATURES$38 = ["MOD"];
var no_component_will_update_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Replace usages of `componentWillUpdate` with `UNSAFE_componentWillUpdate`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$38
		},
		fixable: "code",
		messages: { noComponentWillUpdate: "[Deprecated] Use 'UNSAFE_componentWillUpdate' instead." },
		schema: []
	},
	name: RULE_NAME$40,
	create: create$40,
	defaultOptions: []
});
function create$40(context) {
	if (!context.sourceCode.text.includes("componentWillUpdate")) return {};
	const { ctx, listeners } = useComponentCollectorLegacy();
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const { node: component } of components.values()) {
				const { body } = component.body;
				for (const member of body) if (isComponentWillUpdate(member)) context.report({
					messageId: "noComponentWillUpdate",
					node: member,
					fix(fixer) {
						if (!("key" in member)) return null;
						return fixer.replaceText(member.key, "UNSAFE_componentWillUpdate");
					}
				});
			}
		}
	};
}

//#endregion
//#region src/rules/no-context-provider.ts
const RULE_NAME$39 = "no-context-provider";
const RULE_FEATURES$37 = ["MOD"];
var no_context_provider_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Replace usages of `<Context.Provider>` with `<Context>`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$37
		},
		fixable: "code",
		messages: { noContextProvider: "In React 19, you can render '<Context>' as a provider instead of '<Context.Provider>'." },
		schema: []
	},
	name: RULE_NAME$39,
	create: create$39,
	defaultOptions: []
});
function create$39(context) {
	if (!context.sourceCode.text.includes("Provider")) return {};
	const { version: version$1 } = getSettingsFromContext(context);
	if (compare(version$1, "19.0.0", "<")) return {};
	return { JSXElement(node) {
		const parts = getJsxElementType(context, node).split(".");
		const selfName = parts.pop();
		const contextFullName = parts.join(".");
		const contextSelfName = parts.pop();
		if (selfName !== "Provider") return;
		if (contextSelfName == null) return;
		context.report({
			messageId: "noContextProvider",
			node,
			fix(fixer) {
				if (!isComponentNameLoose(contextSelfName)) return null;
				const openingElement = node.openingElement;
				const closingElement = node.closingElement;
				if (closingElement == null) return fixer.replaceText(openingElement.name, contextFullName);
				return [fixer.replaceText(openingElement.name, contextFullName), fixer.replaceText(closingElement.name, contextFullName)];
			}
		});
	} };
}

//#endregion
//#region src/rules/no-create-ref.ts
const RULE_NAME$38 = "no-create-ref";
const RULE_FEATURES$36 = [];
var no_create_ref_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow `createRef` in function components.",
			[Symbol.for("rule_features")]: RULE_FEATURES$36
		},
		messages: { noCreateRef: "[Deprecated] Use 'useRef' instead." },
		schema: []
	},
	name: RULE_NAME$38,
	create: create$38,
	defaultOptions: []
});
function create$38(context) {
	return { CallExpression(node) {
		if (isCreateRefCall(context, node) && AST.findParentNode(node, isClassComponent) == null) context.report({
			messageId: "noCreateRef",
			node
		});
	} };
}

//#endregion
//#region src/rules/no-default-props.ts
const RULE_NAME$37 = "no-default-props";
const RULE_FEATURES$35 = [];
var no_default_props_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow `defaultProps` property in favor of ES6 default parameters.",
			[Symbol.for("rule_features")]: RULE_FEATURES$35
		},
		messages: { noDefaultProps: "[Deprecated] Use ES6 default parameters instead." },
		schema: []
	},
	name: RULE_NAME$37,
	create: create$37,
	defaultOptions: []
});
function create$37(context) {
	if (!context.sourceCode.text.includes("defaultProps")) return {};
	return { AssignmentExpression(node) {
		if (node.operator !== "=" || node.left.type !== AST_NODE_TYPES.MemberExpression) return;
		const { object, property } = node.left;
		if (object.type !== AST_NODE_TYPES.Identifier) return;
		if (property.type !== AST_NODE_TYPES.Identifier || property.name !== "defaultProps") return;
		if (!isComponentNameLoose(object.name)) return;
		const variable = findVariable(object.name, context.sourceCode.getScope(node));
		const variableNode = getVariableDefinitionNode(variable, 0);
		if (variableNode == null) return;
		if (!AST.isFunction(variableNode)) return;
		context.report({
			messageId: "noDefaultProps",
			node: property
		});
	} };
}

//#endregion
//#region src/rules/no-direct-mutation-state.ts
const RULE_NAME$36 = "no-direct-mutation-state";
const RULE_FEATURES$34 = [];
function isConstructorFunction(node) {
	return AST.isOneOf([AST_NODE_TYPES.FunctionDeclaration, AST_NODE_TYPES.FunctionExpression])(node) && AST.isMethodOrProperty(node.parent) && node.parent.key.type === AST_NODE_TYPES.Identifier && node.parent.key.name === "constructor";
}
var no_direct_mutation_state_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow direct mutation of `this.state`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$34
		},
		messages: { noDirectMutationState: "Do not mutate state directly. Use 'setState()' instead." },
		schema: []
	},
	name: RULE_NAME$36,
	create: create$36,
	defaultOptions: []
});
function create$36(context) {
	return { AssignmentExpression(node) {
		if (!isAssignmentToThisState(node)) return;
		const parentClass = AST.findParentNode(node, AST.isOneOf([AST_NODE_TYPES.ClassDeclaration, AST_NODE_TYPES.ClassExpression]));
		if (parentClass == null) return;
		if (isClassComponent(parentClass) && context.sourceCode.getScope(node).block !== AST.findParentNode(node, isConstructorFunction)) context.report({
			messageId: "noDirectMutationState",
			node
		});
	} };
}

//#endregion
//#region src/rules/no-duplicate-key.ts
const RULE_NAME$35 = "no-duplicate-key";
const RULE_FEATURES$33 = [];
var no_duplicate_key_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow duplicate `key` on elements in the same array or a list of `children`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$33
		},
		messages: { noDuplicateKey: "A key must be unique. '{{value}}' is duplicated." },
		schema: []
	},
	name: RULE_NAME$35,
	create: create$35,
	defaultOptions: []
});
function create$35(context) {
	if (!context.sourceCode.text.includes("key=")) return {};
	const keyedEntries = /* @__PURE__ */ new Map();
	function isKeyValueEqual(a, b) {
		const aValue = a.value;
		const bValue = b.value;
		if (aValue == null || bValue == null) return false;
		return AST.isNodeEqual(aValue, bValue);
	}
	return {
		"JSXAttribute[name.name='key']"(node) {
			const jsxElement = node.parent.parent;
			switch (jsxElement.parent.type) {
				case AST_NODE_TYPES.ArrayExpression:
				case AST_NODE_TYPES.JSXElement:
				case AST_NODE_TYPES.JSXFragment: {
					const root = jsxElement.parent;
					const prevKeys = keyedEntries.get(root)?.keys ?? [];
					keyedEntries.set(root, {
						hasDuplicate: prevKeys.some((prevKey) => isKeyValueEqual(prevKey, node)),
						keys: [...prevKeys, node],
						root: jsxElement.parent
					});
					break;
				}
				default: {
					const call = AST.findParentNode(jsxElement, AST.isArrayMapCall);
					const iter = AST.findParentNode(jsxElement, (n) => n === call || AST.isFunction(n));
					if (!AST.isFunction(iter)) return;
					const arg0 = call?.arguments[0];
					if (call == null || arg0 == null) return;
					if (AST.getUnderlyingExpression(arg0) !== iter) return;
					keyedEntries.set(call, {
						hasDuplicate: node.value?.type === AST_NODE_TYPES.Literal,
						keys: [node],
						root: call
					});
				}
			}
		},
		"Program:exit"() {
			for (const { hasDuplicate, keys } of keyedEntries.values()) {
				if (!hasDuplicate) continue;
				for (const key of keys) context.report({
					messageId: "noDuplicateKey",
					node: key,
					data: { value: context.sourceCode.getText(key) }
				});
			}
		}
	};
}

//#endregion
//#region src/rules/no-forbidden-props.ts
const RULE_NAME$34 = "no-forbidden-props";
const messageId = camelCase(RULE_NAME$34);
const defaultOptions$1 = [{ forbid: [{ prop: "/_/" }] }];
var no_forbidden_props_default = createRule({
	meta: {
		type: "problem",
		defaultOptions: [...defaultOptions$1],
		docs: { description: "Disallow certain props on components." },
		messages: { [messageId]: "Prop \"{{name}}\" is forbidden." },
		schema: [{
			type: "object",
			properties: { forbid: {
				type: "array",
				items: { anyOf: [
					{ type: "string" },
					{
						type: "object",
						additionalProperties: false,
						properties: {
							excludedNodes: {
								type: "array",
								items: { type: "string" },
								uniqueItems: true
							},
							prop: { type: "string" }
						},
						required: ["prop"]
					},
					{
						type: "object",
						additionalProperties: false,
						properties: {
							includedNodes: {
								type: "array",
								items: { type: "string" },
								uniqueItems: true
							},
							prop: { type: "string" }
						},
						required: ["prop"]
					}
				] }
			} }
		}]
	},
	name: RULE_NAME$34,
	create: create$34,
	defaultOptions: defaultOptions$1
});
function create$34(context, [option]) {
	const { forbid = [{ prop: "/_/" }] } = option;
	return { JSXOpeningElement(node) {
		let nodeName = null;
		if (node.name.type === AST_NODE_TYPES.JSXIdentifier) nodeName = node.name.name;
		else if (node.name.type === AST_NODE_TYPES.JSXNamespacedName) nodeName = node.name.name.name;
		for (const attr of node.attributes) {
			if (attr.type === AST_NODE_TYPES.JSXSpreadAttribute) continue;
			const name$4 = attr.name.name;
			if (typeof name$4 !== "string") continue;
			for (const forbiddenPropItem of forbid) {
				if (typeof forbiddenPropItem !== "string" && nodeName != null) {
					if ("excludedNodes" in forbiddenPropItem && forbiddenPropItem.excludedNodes.includes(nodeName)) continue;
					if ("includedNodes" in forbiddenPropItem && !forbiddenPropItem.includedNodes.includes(nodeName)) continue;
				}
				const forbiddenProp = typeof forbiddenPropItem === "string" ? forbiddenPropItem : forbiddenPropItem.prop;
				if (toRegExp(forbiddenProp).test(name$4)) context.report({
					messageId,
					node: attr,
					data: { name: name$4 }
				});
			}
		}
	} };
}

//#endregion
//#region src/rules/no-forward-ref.ts
const RULE_NAME$33 = "no-forward-ref";
const RULE_FEATURES$32 = ["MOD"];
var no_forward_ref_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Replaces usages of `forwardRef` with passing `ref` as a prop.",
			[Symbol.for("rule_features")]: RULE_FEATURES$32
		},
		fixable: "code",
		messages: { noForwardRef: "In React 19, 'forwardRef' is no longer necessary. Pass 'ref' as a prop instead." },
		schema: []
	},
	name: RULE_NAME$33,
	create: create$33,
	defaultOptions: []
});
function create$33(context) {
	if (!context.sourceCode.text.includes("forwardRef")) return {};
	const { version: version$1 } = getSettingsFromContext(context);
	if (compare(version$1, "19.0.0", "<")) return {};
	return { CallExpression(node) {
		if (!isForwardRefCall(context, node)) return;
		const id = AST.getFunctionId(node);
		const fix = canFix$1(context, node) ? getFix$1(context, node) : null;
		context.report({
			messageId: "noForwardRef",
			node: id ?? node,
			fix
		});
	} };
}
/**
* Determines whether the given CallExpression can be safely auto-fixed by replacing
* the usage of `forwardRef` with passing `ref` as a prop
*
* @param context - The rule context object
* @param node - The CallExpression node to check
* @returns True if the call can be auto-fixed, false otherwise
*/
function canFix$1(context, node) {
	const { importSource } = getSettingsFromContext(context);
	const initialScope = context.sourceCode.getScope(node);
	switch (node.callee.type) {
		case AST_NODE_TYPES.Identifier: return isInitializedFromReact(node.callee.name, importSource, initialScope);
		case AST_NODE_TYPES.MemberExpression: return node.callee.object.type === AST_NODE_TYPES.Identifier && isInitializedFromReact(node.callee.object.name, importSource, initialScope);
		default: return false;
	}
}
/**
* Generates the fix for the `forwardRef` call
* @param context - The rule context
* @param node - The `forwardRef` call expression
* @returns A fixer function that applies the changes
*/
function getFix$1(context, node) {
	return (fixer) => {
		const [componentNode] = node.arguments;
		if (componentNode == null || !AST.isFunction(componentNode)) return [];
		return [
			fixer.removeRange([node.range[0], componentNode.range[0]]),
			fixer.removeRange([componentNode.range[1], node.range[1]]),
			...getComponentPropsFixes(context, fixer, componentNode, node.typeArguments?.params ?? [])
		];
	};
}
/**
* Generates fixes for the component's props and ref arguments
* @param context - The rule context
* @param fixer - The rule fixer
* @param node - The function component node
* @param typeArguments - The type arguments from the `forwardRef` call
* @returns An array of fixes for the component's signature
*/
function getComponentPropsFixes(context, fixer, node, typeArguments) {
	const getText = (node$1) => context.sourceCode.getText(node$1);
	const [arg0, arg1] = node.params;
	const [typeArg0, typeArg1] = typeArguments;
	if (arg0 == null) return [];
	const fixedArg0Text = match(arg0).with({ type: AST_NODE_TYPES.Identifier }, (n) => `...${n.name}`).with({ type: AST_NODE_TYPES.ObjectPattern }, (n) => n.properties.map(getText).join(", ")).otherwise(() => null);
	const fixedArg1Text = match(arg1).with(P.nullish, () => "ref").with({
		type: AST_NODE_TYPES.Identifier,
		name: "ref"
	}, () => "ref").with({
		type: AST_NODE_TYPES.Identifier,
		name: P.string
	}, (n) => `ref: ${n.name}`).otherwise(() => null);
	if (fixedArg0Text == null || fixedArg1Text == null) return [];
	if (typeArg0 == null || typeArg1 == null) return [fixer.replaceText(arg0, [
		"{",
		fixedArg1Text + ",",
		fixedArg0Text,
		"}"
	].join(" ")), ...arg1 == null ? [] : [fixer.remove(arg1), fixer.removeRange([arg0.range[1], arg1.range[0]])]];
	const typeArg0Text = getText(typeArg0);
	const typeArg1Text = getText(typeArg1);
	return [fixer.replaceText(arg0, [
		"{",
		fixedArg1Text + ",",
		fixedArg0Text,
		"}:",
		typeArg1Text,
		"&",
		"{",
		`ref?:`,
		`React.RefObject<${typeArg0Text} | null>`,
		"}"
	].join(" ")), ...arg1 == null ? [] : [fixer.remove(arg1), fixer.removeRange([arg0.range[1], arg1.range[0]])]];
}

//#endregion
//#region src/rules/no-implicit-key.ts
const RULE_NAME$32 = "no-implicit-key";
const RULE_FEATURES$31 = ["EXP"];
var no_implicit_key_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents `key` from not being explicitly specified (e.g. spreading `key` from objects).",
			[Symbol.for("rule_features")]: RULE_FEATURES$31
		},
		messages: { noImplicitKey: "Do not use implicit 'key' props." },
		schema: []
	},
	name: RULE_NAME$32,
	create: create$32,
	defaultOptions: []
});
function create$32(context) {
	return { JSXOpeningElement(node) {
		const keyProp = getJsxAttribute(context, node.parent)("key");
		const isKeyPropOnElement = node.attributes.some((n) => n.type === AST_NODE_TYPES.JSXAttribute && n.name.type === AST_NODE_TYPES.JSXIdentifier && n.name.name === "key");
		if (keyProp != null && !isKeyPropOnElement) context.report({
			messageId: "noImplicitKey",
			node: keyProp
		});
	} };
}

//#endregion
//#region src/rules/no-leaked-conditional-rendering.ts
const RULE_NAME$31 = "no-leaked-conditional-rendering";
const RULE_FEATURES$30 = ["TSC"];
var no_leaked_conditional_rendering_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents problematic leaked values from being rendered.",
			[Symbol.for("rule_features")]: RULE_FEATURES$30
		},
		messages: { noLeakedConditionalRendering: "Potential leaked value {{value}} that might cause unintentionally rendered values or rendering crashes." },
		schema: []
	},
	name: RULE_NAME$31,
	create: create$31,
	defaultOptions: []
});
function create$31(context) {
	if (!context.sourceCode.text.includes("&&")) return {};
	const { version: version$1 } = getSettingsFromContext(context);
	const allowedVariants = [
		"any",
		"boolean",
		"nullish",
		"object",
		"falsy boolean",
		"truthy bigint",
		"truthy boolean",
		"truthy number",
		"truthy string",
		...compare(version$1, "18.0.0", "<") ? [] : ["string", "falsy string"]
	];
	const services = ESLintUtils.getParserServices(context, false);
	/**
	* Recursively inspects a node to find potential leaked conditional rendering
	* @param node The AST node to inspect
	* @returns A report descriptor if a problem is found, otherwise `unit`
	*/
	function getReportDescriptor(node) {
		if (node == null) return unit;
		if (AST.is(AST_NODE_TYPES.JSXExpressionContainer)(node)) return getReportDescriptor(node.expression);
		if (AST.isJSX(node)) return unit;
		if (AST.isTypeExpression(node)) return getReportDescriptor(node.expression);
		return match(node).with({
			type: AST_NODE_TYPES.LogicalExpression,
			operator: "&&"
		}, ({ left, right }) => {
			if (left.type === AST_NODE_TYPES.UnaryExpression && left.operator === "!") return getReportDescriptor(right);
			const initialScope = context.sourceCode.getScope(left);
			if (left.type === AST_NODE_TYPES.Identifier && left.name === "NaN" || getStaticValue(left, initialScope)?.value === "NaN") return {
				messageId: "noLeakedConditionalRendering",
				node: left,
				data: { value: context.sourceCode.getText(left) }
			};
			const leftType = getConstrainedTypeAtLocation(services, left);
			const leftTypeVariants = getTypeVariants(unionConstituents(leftType));
			if (Array.from(leftTypeVariants.values()).every((type) => allowedVariants.some((allowed) => allowed === type))) return getReportDescriptor(right);
			return {
				messageId: "noLeakedConditionalRendering",
				node: left,
				data: { value: context.sourceCode.getText(left) }
			};
		}).with({ type: AST_NODE_TYPES.ConditionalExpression }, ({ alternate, consequent }) => {
			return getReportDescriptor(consequent) ?? getReportDescriptor(alternate);
		}).with({ type: AST_NODE_TYPES.Identifier }, (n) => {
			const variableDefNode = findVariable(n.name, context.sourceCode.getScope(n))?.defs.at(0)?.node;
			return match(variableDefNode).with({ init: P.select({ type: P.not(AST_NODE_TYPES.VariableDeclaration) }) }, getReportDescriptor).otherwise(() => unit);
		}).otherwise(() => unit);
	}
	return { JSXExpressionContainer: flow(getReportDescriptor, report(context)) };
}

//#endregion
//#region src/rules/no-missing-component-display-name.ts
const RULE_NAME$30 = "no-missing-component-display-name";
const RULE_FEATURES$29 = [];
var no_missing_component_display_name_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces that all components have a `displayName` which can be used in devtools.",
			[Symbol.for("rule_features")]: RULE_FEATURES$29
		},
		messages: { noMissingComponentDisplayName: "Add missing 'displayName' for component." },
		schema: []
	},
	name: RULE_NAME$30,
	create: create$30,
	defaultOptions: []
});
function create$30(context) {
	if (!context.sourceCode.text.includes("memo") && !context.sourceCode.text.includes("forwardRef")) return {};
	const { ctx, listeners } = useComponentCollector(context, {
		collectDisplayName: true,
		collectHookCalls: false,
		hint: DEFAULT_COMPONENT_DETECTION_HINT
	});
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const { node, displayName, flag } of components.values()) {
				const isMemoOrForwardRef = (flag & (ComponentFlag.ForwardRef | ComponentFlag.Memo)) > 0n;
				if (AST.getFunctionId(node) != null) continue;
				if (!isMemoOrForwardRef) continue;
				if (displayName == null) {
					const id = AST.getFunctionId(node);
					context.report({
						messageId: "noMissingComponentDisplayName",
						node: id ?? node
					});
				}
			}
		}
	};
}

//#endregion
//#region src/rules/no-missing-context-display-name.ts
const RULE_NAME$29 = "no-missing-context-display-name";
const RULE_FEATURES$28 = ["FIX"];
var no_missing_context_display_name_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces that all contexts have a `displayName` which can be used in devtools.",
			[Symbol.for("rule_features")]: RULE_FEATURES$28
		},
		fixable: "code",
		messages: { noMissingContextDisplayName: "Add missing 'displayName' for context." },
		schema: []
	},
	name: RULE_NAME$29,
	create: create$29,
	defaultOptions: []
});
function create$29(context) {
	if (!context.sourceCode.text.includes("createContext")) return {};
	const createCalls = [];
	const displayNameAssignments = [];
	return {
		[AST.SEL_DISPLAY_NAME_ASSIGNMENT_EXPRESSION](node) {
			displayNameAssignments.push(node);
		},
		CallExpression(node) {
			if (!isCreateContextCall(context, node)) return;
			createCalls.push(node);
		},
		"Program:exit"() {
			for (const call of createCalls) {
				const id = getInstanceId(call);
				if (id == null) {
					context.report({
						messageId: "noMissingContextDisplayName",
						node: call
					});
					continue;
				}
				if (!displayNameAssignments.some((node) => {
					const left = node.left;
					if (left.type !== AST_NODE_TYPES.MemberExpression) return false;
					const object = left.object;
					return isInstanceIdEqual(context, id, object);
				})) context.report({
					messageId: "noMissingContextDisplayName",
					node: id,
					fix(fixer) {
						if (id.type !== AST_NODE_TYPES.Identifier || id.parent !== call.parent) return [];
						return fixer.insertTextAfter(context.sourceCode.getTokenAfter(call) ?? call, [
							"\n",
							id.name,
							".",
							"displayName",
							" ",
							"=",
							" ",
							JSON.stringify(id.name),
							";"
						].join(""));
					}
				});
			}
		}
	};
}

//#endregion
//#region src/rules/no-missing-key.ts
const RULE_NAME$28 = "no-missing-key";
const RULE_FEATURES$27 = [];
var no_missing_key_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow missing `key` on items in list rendering.",
			[Symbol.for("rule_features")]: RULE_FEATURES$27
		},
		messages: {
			missingKey: "Missing 'key' for element when rendering list.",
			unexpectedFragmentSyntax: "Use fragment component instead of '<>' because it does not support `key`."
		},
		schema: []
	},
	name: RULE_NAME$28,
	create: create$28,
	defaultOptions: []
});
function create$28(context) {
	const state = { isWithinChildrenToArray: false };
	function checkIteratorElement(node) {
		switch (node.type) {
			case AST_NODE_TYPES.JSXElement:
				if (getJsxAttribute(context, node)("key") == null) return {
					messageId: "missingKey",
					node
				};
				return null;
			case AST_NODE_TYPES.JSXFragment: return {
				messageId: "unexpectedFragmentSyntax",
				node
			};
			default: return null;
		}
	}
	function checkExpression(node) {
		switch (node.type) {
			case AST_NODE_TYPES.ConditionalExpression:
				if ("consequent" in node) return checkIteratorElement(node.consequent) ?? checkIteratorElement(node.alternate);
				return null;
			case AST_NODE_TYPES.JSXElement:
			case AST_NODE_TYPES.JSXFragment: return checkIteratorElement(node);
			case AST_NODE_TYPES.LogicalExpression:
				if ("left" in node) return checkIteratorElement(node.left) ?? checkIteratorElement(node.right);
				return null;
			default: return null;
		}
	}
	function checkBlockStatement(node) {
		const descriptors = [];
		for (const statement of AST.getNestedReturnStatements(node)) {
			if (statement.argument == null) continue;
			const descriptor = checkIteratorElement(statement.argument);
			if (descriptor != null) descriptors.push(descriptor);
		}
		return descriptors;
	}
	return {
		ArrayExpression(node) {
			if (state.isWithinChildrenToArray) return;
			const elements = node.elements.filter(AST.is(AST_NODE_TYPES.JSXElement));
			if (elements.length === 0) return;
			const initialScope = context.sourceCode.getScope(node);
			for (const element of elements) if (getJsxAttribute(context, element, initialScope)("key") == null) context.report({
				messageId: "missingKey",
				node: element
			});
		},
		CallExpression(node) {
			state.isWithinChildrenToArray ||= isChildrenToArrayCall(context, node);
			if (state.isWithinChildrenToArray) return;
			const callback = match(node).when(AST.isArrayMapCall, (n) => n.arguments[0]).when(AST.isArrayFromCall, (n) => n.arguments[1]).otherwise(() => null);
			if (!AST.isFunction(callback)) return;
			const body = callback.body;
			if (body.type === AST_NODE_TYPES.BlockStatement) {
				checkBlockStatement(body).forEach(report(context));
				return;
			}
			report(context)(checkExpression(body));
		},
		"CallExpression:exit"(node) {
			if (!isChildrenToArrayCall(context, node)) return;
			state.isWithinChildrenToArray = false;
		},
		JSXFragment(node) {
			if (state.isWithinChildrenToArray) return;
			if (node.parent.type === AST_NODE_TYPES.ArrayExpression) context.report({
				messageId: "unexpectedFragmentSyntax",
				node
			});
		}
	};
}

//#endregion
//#region src/rules/no-misused-capture-owner-stack.ts
const RULE_NAME$27 = "no-misused-capture-owner-stack";
const RULE_FEATURES$26 = ["EXP"];
var no_misused_capture_owner_stack_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents incorrect usage of `captureOwnerStack`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$26
		},
		fixable: "code",
		messages: {
			missingDevelopmentOnlyCheck: `Don't call 'captureOwnerStack' directly. Use 'if (process.env.NODE_ENV !== "production") {...}' to conditionally access it.`,
			useNamespaceImport: "Don't use named imports of 'captureOwnerStack' in files that are bundled for development and production. Use a namespace import instead."
		},
		schema: []
	},
	name: RULE_NAME$27,
	create: create$27,
	defaultOptions: []
});
function create$27(context) {
	if (!context.sourceCode.text.includes("captureOwnerStack")) return {};
	const { importSource } = getSettingsFromContext(context);
	return {
		CallExpression(node) {
			if (!isCaptureOwnerStackCall(context, node)) return;
			if (AST.findParentNode(node, isDevelopmentOnlyCheck) == null) context.report({
				messageId: "missingDevelopmentOnlyCheck",
				node
			});
		},
		ImportDeclaration(node) {
			if (node.source.value !== importSource) return;
			for (const specifier of node.specifiers) {
				if (specifier.type !== AST_NODE_TYPES.ImportSpecifier) continue;
				if (specifier.imported.type !== AST_NODE_TYPES.Identifier) continue;
				if (specifier.imported.name === "captureOwnerStack") context.report({
					messageId: "useNamespaceImport",
					node: specifier
				});
			}
		}
	};
}
function isDevelopmentOnlyCheck(node) {
	if (node.type !== AST_NODE_TYPES.IfStatement) return false;
	if (AST.isProcessEnvNodeEnvCompare(node.test, "!==", "production")) return true;
	return false;
}

//#endregion
//#region src/rules/no-nested-component-definitions.ts
const RULE_NAME$26 = "no-nested-component-definitions";
const RULE_FEATURES$25 = [];
var no_nested_component_definitions_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow nesting component definitions inside other components.",
			[Symbol.for("rule_features")]: RULE_FEATURES$25
		},
		messages: { noNestedComponentDefinitions: "Do not nest component definitions inside other components or props. {{suggestion}}" },
		schema: []
	},
	name: RULE_NAME$26,
	create: create$26,
	defaultOptions: []
});
function create$26(context) {
	const hint = ComponentDetectionHint.SkipArrayMapArgument | ComponentDetectionHint.SkipNullLiteral | ComponentDetectionHint.SkipUndefined | ComponentDetectionHint.SkipBooleanLiteral | ComponentDetectionHint.SkipStringLiteral | ComponentDetectionHint.SkipNumberLiteral | ComponentDetectionHint.StrictLogical | ComponentDetectionHint.StrictConditional;
	const collector = useComponentCollector(context, { hint });
	const collectorLegacy = useComponentCollectorLegacy();
	return {
		...collector.listeners,
		...collectorLegacy.listeners,
		"Program:exit"(program) {
			const functionComponents = [...collector.ctx.getAllComponents(program).values()];
			const classComponents = [...collectorLegacy.ctx.getAllComponents(program).values()];
			const isFunctionComponent = (node) => {
				return AST.isFunction(node) && functionComponents.some((component) => component.node === node);
			};
			const isClassComponent$1 = (node) => {
				return AST.isClass(node) && classComponents.some((component) => component.node === node);
			};
			for (const { name: name$4, node: component } of functionComponents) {
				if (name$4 == null) continue;
				if (isDirectValueOfRenderPropertyLoose(component)) continue;
				if (isInsideJSXAttributeValue(component)) {
					if (!isDeclaredInRenderPropLoose(component)) context.report({
						messageId: "noNestedComponentDefinitions",
						node: component,
						data: {
							name: name$4,
							suggestion: "Move it to the top level or pass it as a prop."
						}
					});
					continue;
				}
				if (isInsideCreateElementProps(context, component)) {
					context.report({
						messageId: "noNestedComponentDefinitions",
						node: component,
						data: {
							name: name$4,
							suggestion: "Move it to the top level or pass it as a prop."
						}
					});
					continue;
				}
				const parentComponent = AST.findParentNode(component, isFunctionComponent);
				if (parentComponent != null && !isDirectValueOfRenderPropertyLoose(parentComponent)) {
					context.report({
						messageId: "noNestedComponentDefinitions",
						node: component,
						data: {
							name: name$4,
							suggestion: component.parent.type === AST_NODE_TYPES.Property ? "Move it to the top level or pass it as a prop." : "Move it to the top level."
						}
					});
					continue;
				}
				if (isInsideRenderMethod(component)) context.report({
					messageId: "noNestedComponentDefinitions",
					node: component,
					data: {
						name: name$4,
						suggestion: "Move it to the top level."
					}
				});
			}
			for (const { name: name$4 = "unknown", node: component } of classComponents) {
				if (AST.findParentNode(component, (n) => isClassComponent$1(n) || isFunctionComponent(n)) == null) continue;
				context.report({
					messageId: "noNestedComponentDefinitions",
					node: component,
					data: {
						name: name$4,
						suggestion: component.parent.type === AST_NODE_TYPES.Property ? "Move it to the top level or pass it as a prop." : "Move it to the top level."
					}
				});
			}
		}
	};
}
/**
* Determines whether the node is inside JSX attribute value
* @param node The AST node to check
* @returns `true` if the node is inside JSX attribute value
*/
function isInsideJSXAttributeValue(node) {
	return node.parent.type === AST_NODE_TYPES.JSXAttribute || findParentJsxAttribute(node, (n) => n.value?.type === AST_NODE_TYPES.JSXExpressionContainer) != null;
}
/**
* Checks whether a given node is declared inside a class component's render block
* Ex: class C extends React.Component { render() { const Nested = () => <div />; } }
* @param node The AST node being checked
* @returns `true` if the node is inside a class component's render block
*/
function isInsideRenderMethod(node) {
	return AST.findParentNode(node, (n) => isRenderMethodLike(n) && isClassComponent(n.parent.parent)) != null;
}
/**
* Determines whether the node is inside `createElement`'s props argument
* @param context The rule context
* @param node The AST node to check
* @returns `true` if the node is inside `createElement`'s props
*/
function isInsideCreateElementProps(context, node) {
	const call = AST.findParentNode(node, isCreateElementCall(context));
	if (call == null) return false;
	const prop = AST.findParentNode(node, AST.is(AST_NODE_TYPES.ObjectExpression));
	if (prop == null) return false;
	return prop === call.arguments[1];
}

//#endregion
//#region src/rules/no-nested-lazy-component-declarations.ts
const RULE_NAME$25 = "no-nested-lazy-component-declarations";
const RULE_FEATURES$24 = [];
var no_nested_lazy_component_declarations_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow nesting lazy component declarations inside other components.",
			[Symbol.for("rule_features")]: RULE_FEATURES$24
		},
		messages: { noNestedLazyComponentDeclarations: "Do not declare lazy components inside other components. Instead, always declare them at the top level of your module." },
		schema: []
	},
	name: RULE_NAME$25,
	create: create$25,
	defaultOptions: []
});
function create$25(context) {
	const hint = ComponentDetectionHint.None;
	const collector = useComponentCollector(context, { hint });
	const collectorLegacy = useComponentCollectorLegacy();
	const lazyComponentDeclarations = /* @__PURE__ */ new Set();
	return {
		...collector.listeners,
		...collectorLegacy.listeners,
		ImportExpression(node) {
			const lazyCall = AST.findParentNode(node, (n) => isLazyCall(context, n));
			if (lazyCall != null) lazyComponentDeclarations.add(lazyCall);
		},
		"Program:exit"(program) {
			const functionComponents = [...collector.ctx.getAllComponents(program).values()];
			const classComponents = [...collectorLegacy.ctx.getAllComponents(program).values()];
			for (const lazy of lazyComponentDeclarations) if (AST.findParentNode(lazy, (n) => {
				if (AST.isJSX(n)) return true;
				if (n.type === AST_NODE_TYPES.CallExpression) return isReactHookCall(n) || isCreateElementCall(context, n) || isCreateContextCall(context, n);
				if (AST.isFunction(n)) return functionComponents.some((c) => c.node === n);
				if (AST.isClass(n)) return classComponents.some((c) => c.node === n);
				return false;
			}) != null) context.report({
				messageId: "noNestedLazyComponentDeclarations",
				node: lazy
			});
		}
	};
}

//#endregion
//#region src/rules/no-prop-types.ts
const RULE_NAME$24 = "no-prop-types";
const RULE_FEATURES$23 = [];
var no_prop_types_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow `propTypes` in favor of TypeScript or another type-checking solution.",
			[Symbol.for("rule_features")]: RULE_FEATURES$23
		},
		messages: { noPropTypes: "[Deprecated] Use TypeScript or another type-checking solution instead." },
		schema: []
	},
	name: RULE_NAME$24,
	create: create$24,
	defaultOptions: []
});
function create$24(context) {
	if (!context.sourceCode.text.includes("propTypes")) return {};
	return {
		AssignmentExpression(node) {
			if (node.operator !== "=" || node.left.type !== AST_NODE_TYPES.MemberExpression) return;
			const { object, property } = node.left;
			if (object.type !== AST_NODE_TYPES.Identifier) return;
			if (property.type !== AST_NODE_TYPES.Identifier || property.name !== "propTypes") return;
			if (!isComponentNameLoose(object.name)) return;
			const variable = findVariable(object.name, context.sourceCode.getScope(node));
			const variableNode = getVariableDefinitionNode(variable, 0);
			if (variableNode != null && (AST.isFunction(variableNode) || isClassComponent(variableNode))) context.report({
				messageId: "noPropTypes",
				node: property
			});
		},
		PropertyDefinition(node) {
			if (!isClassComponent(node.parent.parent)) return;
			if (!node.static || node.key.type !== AST_NODE_TYPES.Identifier || node.key.name !== "propTypes") return;
			context.report({
				messageId: "noPropTypes",
				node
			});
		}
	};
}

//#endregion
//#region src/rules/no-redundant-should-component-update.ts
const RULE_NAME$23 = "no-redundant-should-component-update";
const RULE_FEATURES$22 = [];
function isShouldComponentUpdate(node) {
	return AST.isMethodOrProperty(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "shouldComponentUpdate";
}
var no_redundant_should_component_update_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow `shouldComponentUpdate` when extending `React.PureComponent`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$22
		},
		messages: { noRedundantShouldComponentUpdate: "'{{componentName}}' does not need 'shouldComponentUpdate' when extending 'React.PureComponent'." },
		schema: []
	},
	name: RULE_NAME$23,
	create: create$23,
	defaultOptions: []
});
function create$23(context) {
	if (!context.sourceCode.text.includes("shouldComponentUpdate")) return {};
	const { ctx, listeners } = useComponentCollectorLegacy();
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const { name: name$4 = "PureComponent", node: component, flag } of components.values()) {
				if ((flag & ComponentFlag.PureComponent) === 0n) continue;
				const { body } = component.body;
				for (const member of body) if (isShouldComponentUpdate(member)) context.report({
					messageId: "noRedundantShouldComponentUpdate",
					node: member,
					data: { componentName: name$4 }
				});
			}
		}
	};
}

//#endregion
//#region src/rules/no-set-state-in-component-did-mount.ts
const RULE_NAME$22 = "no-set-state-in-component-did-mount";
const RULE_FEATURES$21 = [];
var no_set_state_in_component_did_mount_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow calling `this.setState` in `componentDidMount` outside of functions, such as callbacks.",
			[Symbol.for("rule_features")]: RULE_FEATURES$21
		},
		messages: { noSetStateInComponentDidMount: "Do not call `this.setState` in `componentDidMount` outside of functions, such as callbacks." },
		schema: []
	},
	name: RULE_NAME$22,
	create: create$22,
	defaultOptions: []
});
function create$22(context) {
	if (!context.sourceCode.text.includes("componentDidMount")) return {};
	return { CallExpression(node) {
		if (!isThisSetState(node)) return;
		const enclosingClassNode = AST.findParentNode(node, isClassComponent);
		const enclosingMethodNode = AST.findParentNode(node, (n) => n === enclosingClassNode || isComponentDidMount(n));
		if (enclosingClassNode == null || enclosingMethodNode == null || enclosingMethodNode === enclosingClassNode) return;
		const enclosingMethodScope = context.sourceCode.getScope(enclosingMethodNode);
		const setStateCallParentScope = context.sourceCode.getScope(node).upper;
		if (enclosingMethodNode.parent === enclosingClassNode.body && setStateCallParentScope === enclosingMethodScope) context.report({
			messageId: "noSetStateInComponentDidMount",
			node
		});
	} };
}

//#endregion
//#region src/rules/no-set-state-in-component-did-update.ts
const RULE_NAME$21 = "no-set-state-in-component-did-update";
const RULE_FEATURES$20 = [];
var no_set_state_in_component_did_update_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow calling `this.setState` in `componentDidUpdate` outside of functions, such as callbacks.",
			[Symbol.for("rule_features")]: RULE_FEATURES$20
		},
		messages: { noSetStateInComponentDidUpdate: "Do not call `this.setState` in `componentDidUpdate` outside of functions, such as callbacks." },
		schema: []
	},
	name: RULE_NAME$21,
	create: create$21,
	defaultOptions: []
});
function create$21(context) {
	if (!context.sourceCode.text.includes("componentDidUpdate")) return {};
	return { CallExpression(node) {
		if (!isThisSetState(node)) return;
		const enclosingClassNode = AST.findParentNode(node, isClassComponent);
		const enclosingMethodNode = AST.findParentNode(node, (n) => n === enclosingClassNode || isComponentDidUpdate(n));
		if (enclosingClassNode == null || enclosingMethodNode == null || enclosingMethodNode === enclosingClassNode) return;
		const enclosingMethodScope = context.sourceCode.getScope(enclosingMethodNode);
		const setStateCallParentScope = context.sourceCode.getScope(node).upper;
		if (enclosingMethodNode.parent === enclosingClassNode.body && setStateCallParentScope === enclosingMethodScope) context.report({
			messageId: "noSetStateInComponentDidUpdate",
			node
		});
	} };
}

//#endregion
//#region src/rules/no-set-state-in-component-will-update.ts
const RULE_NAME$20 = "no-set-state-in-component-will-update";
const RULE_FEATURES$19 = [];
var no_set_state_in_component_will_update_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow calling `this.setState` in `componentWillUpdate` outside of functions, such as callbacks.",
			[Symbol.for("rule_features")]: RULE_FEATURES$19
		},
		messages: { noSetStateInComponentWillUpdate: "Do not call `this.setState` in `componentWillUpdate` outside of functions, such as callbacks." },
		schema: []
	},
	name: RULE_NAME$20,
	create: create$20,
	defaultOptions: []
});
function create$20(context) {
	if (!context.sourceCode.text.includes("componentWillUpdate")) return {};
	return { CallExpression(node) {
		if (!isThisSetState(node)) return;
		const enclosingClassNode = AST.findParentNode(node, isClassComponent);
		const enclosingMethodNode = AST.findParentNode(node, (n) => n === enclosingClassNode || isComponentWillUpdate(n));
		if (enclosingClassNode == null || enclosingMethodNode == null || enclosingMethodNode === enclosingClassNode) return;
		const enclosingMethodScope = context.sourceCode.getScope(enclosingMethodNode);
		const setStateCallParentScope = context.sourceCode.getScope(node).upper;
		if (enclosingMethodNode.parent === enclosingClassNode.body && setStateCallParentScope === enclosingMethodScope) context.report({
			messageId: "noSetStateInComponentWillUpdate",
			node
		});
	} };
}

//#endregion
//#region src/rules/no-string-refs.ts
const RULE_NAME$19 = "no-string-refs";
const RULE_FEATURES$18 = ["MOD"];
var no_string_refs_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Replaces string refs with callback refs.",
			[Symbol.for("rule_features")]: RULE_FEATURES$18
		},
		fixable: "code",
		messages: { noStringRefs: "[Deprecated] Use callback refs instead." },
		schema: []
	},
	name: RULE_NAME$19,
	create: create$19,
	defaultOptions: []
});
function create$19(context) {
	const state = { isWithinClassComponent: false };
	function onClassBodyEnter(node) {
		if (isClassComponent(node.parent)) state.isWithinClassComponent = true;
	}
	function onClassBodyExit() {
		state.isWithinClassComponent = false;
	}
	return {
		ClassBody: onClassBodyEnter,
		"ClassBody:exit": onClassBodyExit,
		JSXAttribute(node) {
			if (node.name.name !== "ref") return;
			const refName = getJsxAttributeValueText(context, node.value);
			if (refName == null) return;
			context.report({
				messageId: "noStringRefs",
				node,
				fix(fixer) {
					if (node.value == null) return null;
					if (!state.isWithinClassComponent) return null;
					return fixer.replaceText(node.value, `{(ref) => { this.refs[${refName}] = ref; }}`);
				}
			});
		}
	};
}
/**
* Extracts the text content from a JSX attribute's value
* @param context - The rule context
* @param node - The JSX attribute value node
* @returns The text of the attribute value, or null if not a string-like value
*/
function getJsxAttributeValueText(context, node) {
	if (node == null) return null;
	switch (true) {
		case node.type === AST_NODE_TYPES.Literal && typeof node.value === "string": return context.sourceCode.getText(node);
		case node.type === AST_NODE_TYPES.JSXExpressionContainer && node.expression.type === AST_NODE_TYPES.Literal && typeof node.expression.value === "string": return context.sourceCode.getText(node.expression);
		case node.type === AST_NODE_TYPES.JSXExpressionContainer && node.expression.type === AST_NODE_TYPES.TemplateLiteral: return context.sourceCode.getText(node.expression);
		default: return null;
	}
}

//#endregion
//#region src/rules/no-unnecessary-key.ts
const RULE_NAME$18 = "no-unnecessary-key";
const RULE_FEATURES$17 = ["EXP"];
var no_unnecessary_key_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents the use of unnecessary `key` props on JSX elements when rendering lists.",
			[Symbol.for("rule_features")]: RULE_FEATURES$17
		},
		messages: { noUnnecessaryKey: "Unnecessary `key` prop on this element. The `key` should be on the top-level element returned from the array." },
		schema: []
	},
	name: RULE_NAME$18,
	create: create$18,
	defaultOptions: []
});
function create$18(context) {
	if (!context.sourceCode.text.includes("key=")) return {};
	return { JSXAttribute(node) {
		if (node.name.name !== "key") return;
		const jsxElement = node.parent.parent;
		const initialScope = context.sourceCode.getScope(jsxElement);
		const pMapCallback = AST.findParentNode(jsxElement, isMapCallback);
		if (pMapCallback == null || context.sourceCode.getScope(pMapCallback) !== initialScope) return;
		const pKeyedElementOrElse = AST.findParentNode(jsxElement, (n) => {
			if (n === pMapCallback) return true;
			return AST.isJSXElement(n) && n.openingElement.attributes.some((n$1) => n$1.type === AST_NODE_TYPES.JSXAttribute && n$1.name.type === AST_NODE_TYPES.JSXIdentifier && n$1.name.name === "key");
		});
		if (pKeyedElementOrElse == null || pKeyedElementOrElse === pMapCallback) return;
		context.report({
			messageId: "noUnnecessaryKey",
			node
		});
	} };
}
/**
* Checks if a node is a callback function passed to an array's `.map()` method
* @param node The node to check
* @returns `true` if the node is a map callback, `false` otherwise
*/
function isMapCallback(node) {
	if (node.parent == null) return false;
	if (!AST.isArrayMapCall(node.parent)) return false;
	return AST.isOneOf([AST_NODE_TYPES.ArrowFunctionExpression, AST_NODE_TYPES.FunctionExpression])(AST.getUnderlyingExpression(node));
}

//#endregion
//#region src/rules/no-unnecessary-use-callback.ts
const RULE_NAME$17 = "no-unnecessary-use-callback";
const RULE_FEATURES$16 = ["EXP"];
var no_unnecessary_use_callback_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow unnecessary usage of `useCallback`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$16
		},
		messages: { noUnnecessaryUseCallback: "An 'useCallback' with empty deps and no references to the component scope may be unnecessary." },
		schema: []
	},
	name: RULE_NAME$17,
	create: create$17,
	defaultOptions: []
});
function create$17(context) {
	if (!context.sourceCode.text.includes("useCallback")) return {};
	return { CallExpression(node) {
		if (!isUseCallbackCall(node)) return;
		const initialScope = context.sourceCode.getScope(node);
		const component = context.sourceCode.getScope(node).block;
		if (!AST.isFunction(component)) return;
		const [arg0, arg1] = node.arguments;
		if (arg0 == null || arg1 == null) return;
		if (!match(arg1).with({ type: AST_NODE_TYPES.ArrayExpression }, (n) => n.elements.length === 0).with({ type: AST_NODE_TYPES.Identifier }, (n) => {
			const variable = findVariable(n.name, initialScope);
			const variableNode = getVariableDefinitionNode(variable, 0);
			if (variableNode?.type !== AST_NODE_TYPES.ArrayExpression) return false;
			return variableNode.elements.length === 0;
		}).otherwise(() => false)) return;
		const arg0Node = match(arg0).with({ type: AST_NODE_TYPES.ArrowFunctionExpression }, (n) => {
			if (n.body.type === AST_NODE_TYPES.ArrowFunctionExpression) return n.body;
			return n;
		}).with({ type: AST_NODE_TYPES.FunctionExpression }, identity).with({ type: AST_NODE_TYPES.Identifier }, (n) => {
			const variable = findVariable(n.name, initialScope);
			const variableNode = getVariableDefinitionNode(variable, 0);
			if (variableNode?.type !== AST_NODE_TYPES.ArrowFunctionExpression && variableNode?.type !== AST_NODE_TYPES.FunctionExpression) return null;
			return variableNode;
		}).otherwise(() => null);
		if (arg0Node == null) return;
		const arg0NodeScope = context.sourceCode.getScope(arg0Node);
		if (!getChildScopes(arg0NodeScope).flatMap((x) => x.references).some((x) => x.resolved?.scope.block === component)) context.report({
			messageId: "noUnnecessaryUseCallback",
			node
		});
	} };
}

//#endregion
//#region src/rules/no-unnecessary-use-memo.ts
const RULE_NAME$16 = "no-unnecessary-use-memo";
const RULE_FEATURES$15 = ["EXP"];
var no_unnecessary_use_memo_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow unnecessary usage of `useMemo`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$15
		},
		messages: { noUnnecessaryUseMemo: "An 'useMemo' with empty deps and no references to the component scope may be unnecessary." },
		schema: []
	},
	name: RULE_NAME$16,
	create: create$16,
	defaultOptions: []
});
function create$16(context) {
	if (!context.sourceCode.text.includes("useMemo")) return {};
	return { CallExpression(node) {
		const initialScope = context.sourceCode.getScope(node);
		if (!isUseMemoCall(node)) return;
		const component = context.sourceCode.getScope(node).block;
		if (!AST.isFunction(component)) return;
		const [arg0, arg1] = node.arguments;
		if (arg0 == null || arg1 == null) return;
		if (AST.isFunction(arg0) && [...AST.getNestedCallExpressions(arg0.body), ...AST.getNestedNewExpressions(arg0.body)].length > 0) return;
		if (!match(arg1).with({ type: AST_NODE_TYPES.ArrayExpression }, (n) => n.elements.length === 0).with({ type: AST_NODE_TYPES.Identifier }, (n) => {
			const variable = findVariable(n.name, initialScope);
			const variableNode = getVariableDefinitionNode(variable, 0);
			if (variableNode?.type !== AST_NODE_TYPES.ArrayExpression) return false;
			return variableNode.elements.length === 0;
		}).otherwise(() => false)) return;
		const arg0Node = match(arg0).with({ type: AST_NODE_TYPES.ArrowFunctionExpression }, (n) => {
			if (n.body.type === AST_NODE_TYPES.ArrowFunctionExpression) return n.body;
			return n;
		}).with({ type: AST_NODE_TYPES.FunctionExpression }, identity).with({ type: AST_NODE_TYPES.Identifier }, (n) => {
			const variable = findVariable(n.name, initialScope);
			const variableNode = getVariableDefinitionNode(variable, 0);
			if (variableNode?.type !== AST_NODE_TYPES.ArrowFunctionExpression && variableNode?.type !== AST_NODE_TYPES.FunctionExpression) return null;
			return variableNode;
		}).otherwise(() => null);
		if (arg0Node == null) return;
		const arg0NodeScope = context.sourceCode.getScope(arg0Node);
		if (!getChildScopes(arg0NodeScope).flatMap((x) => x.references).some((x) => x.resolved?.scope.block === component)) context.report({
			messageId: "noUnnecessaryUseMemo",
			node
		});
	} };
}

//#endregion
//#region src/rules/no-unnecessary-use-prefix.ts
const RULE_NAME$15 = "no-unnecessary-use-prefix";
const RULE_FEATURES$14 = ["EXP"];
const WELL_KNOWN_HOOKS = ["useMDXComponents"];
function containsUseComments(context, node) {
	return context.sourceCode.getCommentsInside(node).some(({ value }) => /use\([\s\S]*?\)/u.test(value) || /use[A-Z0-9]\w*\([\s\S]*?\)/u.test(value));
}
var no_unnecessary_use_prefix_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces that a function with the `use` prefix should use at least one Hook inside of it.",
			[Symbol.for("rule_features")]: RULE_FEATURES$14
		},
		messages: { noUnnecessaryUsePrefix: "If your function doesn't call any Hooks, avoid the 'use' prefix. Instead, write it as a regular function without the 'use' prefix." },
		schema: []
	},
	name: RULE_NAME$15,
	create: create$15,
	defaultOptions: []
});
function create$15(context) {
	const { ctx, listeners } = useHookCollector();
	return {
		...listeners,
		"Program:exit"(program) {
			const allHooks = ctx.getAllHooks(program);
			for (const { id, name: name$4, node, hookCalls } of allHooks.values()) {
				if (hookCalls.length > 0) continue;
				if (AST.isFunctionEmpty(node)) continue;
				if (WELL_KNOWN_HOOKS.includes(name$4)) continue;
				if (containsUseComments(context, node)) continue;
				if (AST.findParentNode(node, AST.isViMockCallback) != null) continue;
				context.report({
					messageId: "noUnnecessaryUsePrefix",
					node: id ?? node,
					data: { name: name$4 }
				});
			}
		}
	};
}

//#endregion
//#region src/rules/no-unsafe-component-will-mount.ts
const RULE_NAME$14 = "no-unsafe-component-will-mount";
const RULE_FEATURES$13 = [];
var no_unsafe_component_will_mount_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Warns the usage of `UNSAFE_componentWillMount` in class components.",
			[Symbol.for("rule_features")]: RULE_FEATURES$13
		},
		messages: { noUnsafeComponentWillMount: "Do not use 'UNSAFE_componentWillMount'." },
		schema: []
	},
	name: RULE_NAME$14,
	create: create$14,
	defaultOptions: []
});
function create$14(context) {
	if (!context.sourceCode.text.includes("UNSAFE_componentWillMount")) return {};
	const { ctx, listeners } = useComponentCollectorLegacy();
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const { node: component } of components.values()) {
				const { body } = component.body;
				for (const member of body) if (isUnsafeComponentWillMount(member)) context.report({
					messageId: "noUnsafeComponentWillMount",
					node: member
				});
			}
		}
	};
}

//#endregion
//#region src/rules/no-unsafe-component-will-receive-props.ts
const RULE_NAME$13 = "no-unsafe-component-will-receive-props";
const RULE_FEATURES$12 = [];
var no_unsafe_component_will_receive_props_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Warns the usage of `UNSAFE_componentWillReceiveProps` in class components.",
			[Symbol.for("rule_features")]: RULE_FEATURES$12
		},
		messages: { noUnsafeComponentWillReceiveProps: "Do not use 'UNSAFE_componentWillReceiveProps'." },
		schema: []
	},
	name: RULE_NAME$13,
	create: create$13,
	defaultOptions: []
});
function create$13(context) {
	if (!context.sourceCode.text.includes("UNSAFE_componentWillReceiveProps")) return {};
	const { ctx, listeners } = useComponentCollectorLegacy();
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const { node: component } of components.values()) {
				const { body } = component.body;
				for (const member of body) if (isUnsafeComponentWillReceiveProps(member)) context.report({
					messageId: "noUnsafeComponentWillReceiveProps",
					node: member
				});
			}
		}
	};
}

//#endregion
//#region src/rules/no-unsafe-component-will-update.ts
const RULE_NAME$12 = "no-unsafe-component-will-update";
const RULE_FEATURES$11 = [];
var no_unsafe_component_will_update_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Warns the usage of `UNSAFE_componentWillUpdate` in class components.",
			[Symbol.for("rule_features")]: RULE_FEATURES$11
		},
		messages: { noUnsafeComponentWillUpdate: "Do not use 'UNSAFE_componentWillUpdate'." },
		schema: []
	},
	name: RULE_NAME$12,
	create: create$12,
	defaultOptions: []
});
function create$12(context) {
	if (!context.sourceCode.text.includes("UNSAFE_componentWillUpdate")) return {};
	const { ctx, listeners } = useComponentCollectorLegacy();
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const { node: component } of components.values()) {
				const { body } = component.body;
				for (const member of body) if (isUnsafeComponentWillUpdate(member)) context.report({
					messageId: "noUnsafeComponentWillUpdate",
					node: member
				});
			}
		}
	};
}

//#endregion
//#region src/rules/no-unstable-context-value.ts
const RULE_NAME$11 = "no-unstable-context-value";
const RULE_FEATURES$10 = [];
var no_unstable_context_value_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents non-stable values (i.e. object literals) from being used as a value for `Context.Provider`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$10
		},
		messages: { unstableContextValue: "A/an '{{type}}' passed as the value prop to the context provider should not be constructed. It will change on every render. {{suggestion}}" },
		schema: []
	},
	name: RULE_NAME$11,
	create: create$11,
	defaultOptions: []
});
function create$11(context) {
	const { version: version$1 } = getSettingsFromContext(context);
	const isReact18OrBelow = compare(version$1, "19.0.0", "<");
	const { ctx, listeners } = useComponentCollector(context);
	const constructions = /* @__PURE__ */ new WeakMap();
	return {
		...listeners,
		JSXOpeningElement(node) {
			const selfName = getJsxElementType(context, node.parent).split(".").at(-1);
			if (selfName == null) return;
			if (!isContextName(selfName, isReact18OrBelow)) return;
			const functionEntry = ctx.getCurrentEntry();
			if (functionEntry == null) return;
			const attribute = node.attributes.find((attribute$1) => attribute$1.type === AST_NODE_TYPES.JSXAttribute && attribute$1.name.name === "value");
			if (attribute == null || !("value" in attribute)) return;
			const value = attribute.value;
			if (value?.type !== AST_NODE_TYPES.JSXExpressionContainer) return;
			const valueExpression = value.expression;
			const initialScope = context.sourceCode.getScope(valueExpression);
			const construction = getConstruction(valueExpression, initialScope);
			if (construction == null) return;
			if (isReactHookCall(construction.node)) return;
			getOrElseUpdate(constructions, functionEntry.node, () => []).push(construction);
		},
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program).values();
			for (const { node: component } of components) for (const construction of constructions.get(component) ?? []) {
				const { kind, node: constructionNode } = construction;
				const suggestion = kind.startsWith("Function") ? "Consider wrapping it in a useCallback hook." : "Consider wrapping it in a useMemo hook.";
				context.report({
					messageId: "unstableContextValue",
					node: constructionNode,
					data: {
						type: AST.toDelimiterFormat(constructionNode),
						suggestion
					}
				});
			}
		}
	};
}
function isContextName(name$4, isReact18OrBelow) {
	if (name$4 === "Provider") return true;
	if (!isReact18OrBelow) return name$4.endsWith("Context") || name$4.endsWith("CONTEXT");
	return false;
}

//#endregion
//#region src/rules/no-unstable-default-props.ts
const RULE_NAME$10 = "no-unstable-default-props";
const RULE_FEATURES$9 = [];
var no_unstable_default_props_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents using referential-type values as default props in object destructuring.",
			[Symbol.for("rule_features")]: RULE_FEATURES$9
		},
		messages: { noUnstableDefaultProps: "A/an '{{forbiddenType}}' as default prop. This could lead to potential infinite render loop in React. Use a variable instead of '{{forbiddenType}}'." },
		schema: []
	},
	name: RULE_NAME$10,
	create: create$10,
	defaultOptions: []
});
function create$10(context) {
	const { ctx, listeners } = useComponentCollector(context);
	const declarators = /* @__PURE__ */ new WeakMap();
	return {
		...listeners,
		[AST.SEL_OBJECT_DESTRUCTURING_VARIABLE_DECLARATOR](node) {
			const functionEntry = ctx.getCurrentEntry();
			if (functionEntry == null) return;
			getOrElseUpdate(declarators, functionEntry.node, () => []).push(node);
		},
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const { node: component } of components.values()) {
				const { params } = component;
				const [props] = params;
				if (props == null) continue;
				const properties = match(props).with({ type: AST_NODE_TYPES.ObjectPattern }, ({ properties: properties$1 }) => properties$1).with({ type: AST_NODE_TYPES.Identifier }, ({ name: name$4 }) => {
					return declarators.get(component)?.filter((d) => d.init.name === name$4).flatMap((d) => d.id.properties) ?? [];
				}).otherwise(() => []);
				for (const prop of properties) {
					if (prop.type !== AST_NODE_TYPES.Property || prop.value.type !== AST_NODE_TYPES.AssignmentPattern) continue;
					const { value } = prop;
					const { right } = value;
					const initialScope = context.sourceCode.getScope(value);
					const construction = getConstruction(value, initialScope, ConstructionDetectionHint.StrictCallExpression);
					if (construction == null) continue;
					if (isReactHookCall(construction.node)) continue;
					const forbiddenType = AST.toDelimiterFormat(right);
					context.report({
						messageId: "noUnstableDefaultProps",
						node: right,
						data: { forbiddenType }
					});
				}
			}
		}
	};
}

//#endregion
//#region src/rules/no-unused-class-component-members.ts
const RULE_NAME$9 = "no-unused-class-component-members";
const RULE_FEATURES$8 = [];
const LIFECYCLE_METHODS = new Set([
	"componentDidCatch",
	"componentDidMount",
	"componentDidUpdate",
	"componentWillMount",
	"componentWillReceiveProps",
	"componentWillUnmount",
	"componentWillUpdate",
	"constructor",
	"getSnapshotBeforeUpdate",
	"render",
	"shouldComponentUpdate",
	"state",
	"UNSAFE_componentWillMount",
	"UNSAFE_componentWillReceiveProps",
	"UNSAFE_componentWillUpdate"
]);
function isKeyLiteral$1(node, key) {
	return match(key).with({ type: AST_NODE_TYPES.Literal }, constTrue).with({
		type: AST_NODE_TYPES.TemplateLiteral,
		expressions: []
	}, constTrue).with({ type: AST_NODE_TYPES.Identifier }, () => !node.computed).otherwise(constFalse);
}
var no_unused_class_component_members_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Warns unused class component methods and properties.",
			[Symbol.for("rule_features")]: RULE_FEATURES$8
		},
		messages: { noUnusedClassComponentMembers: "Unused method or property '{{methodName}}'' of class '{{className}}'." },
		schema: []
	},
	name: RULE_NAME$9,
	create: create$9,
	defaultOptions: []
});
function create$9(context) {
	const classStack = [];
	const methodStack = [];
	const propertyDefs = /* @__PURE__ */ new WeakMap();
	const propertyUsages = /* @__PURE__ */ new WeakMap();
	function classEnter(node) {
		classStack.push(node);
		if (!isClassComponent(node)) return;
		propertyDefs.set(node, /* @__PURE__ */ new Set());
		propertyUsages.set(node, /* @__PURE__ */ new Set());
	}
	function classExit() {
		const currentClass = classStack.pop();
		if (currentClass == null || !isClassComponent(currentClass)) return;
		const className = AST.getClassId(currentClass)?.name;
		const defs = propertyDefs.get(currentClass);
		const usages = propertyUsages.get(currentClass);
		if (defs == null) return;
		for (const def of defs) {
			const methodName = AST.getPropertyName(def);
			if (methodName == null) continue;
			if ((usages?.has(methodName) ?? false) || LIFECYCLE_METHODS.has(methodName)) continue;
			context.report({
				messageId: "noUnusedClassComponentMembers",
				node: def,
				data: {
					className: className ?? "Component",
					methodName
				}
			});
		}
	}
	function methodEnter(node) {
		methodStack.push(node);
		const currentClass = classStack.at(-1);
		if (currentClass == null || !isClassComponent(currentClass)) return;
		if (node.static) return;
		if (isKeyLiteral$1(node, node.key)) propertyDefs.get(currentClass)?.add(node.key);
	}
	function methodExit() {
		methodStack.pop();
	}
	return {
		ClassDeclaration: classEnter,
		"ClassDeclaration:exit": classExit,
		ClassExpression: classEnter,
		"ClassExpression:exit": classExit,
		MemberExpression(node) {
			const currentClass = classStack.at(-1);
			const currentMethod = methodStack.at(-1);
			if (currentClass == null || currentMethod == null) return;
			if (!isClassComponent(currentClass) || currentMethod.static) return;
			if (!AST.isThisExpression(node.object) || !isKeyLiteral$1(node, node.property)) return;
			if (node.parent.type === AST_NODE_TYPES.AssignmentExpression && node.parent.left === node) {
				propertyDefs.get(currentClass)?.add(node.property);
				return;
			}
			const propertyName = AST.getPropertyName(node.property);
			if (propertyName != null) propertyUsages.get(currentClass)?.add(propertyName);
		},
		MethodDefinition: methodEnter,
		"MethodDefinition:exit": methodExit,
		PropertyDefinition: methodEnter,
		"PropertyDefinition:exit": methodExit,
		VariableDeclarator(node) {
			const currentClass = classStack.at(-1);
			const currentMethod = methodStack.at(-1);
			if (currentClass == null || currentMethod == null) return;
			if (!isClassComponent(currentClass) || currentMethod.static) return;
			if (node.init != null && AST.isThisExpression(node.init) && node.id.type === AST_NODE_TYPES.ObjectPattern) {
				for (const prop of node.id.properties) if (prop.type === AST_NODE_TYPES.Property && isKeyLiteral$1(prop, prop.key)) {
					const keyName = AST.getPropertyName(prop.key);
					if (keyName != null) propertyUsages.get(currentClass)?.add(keyName);
				}
			}
		}
	};
}

//#endregion
//#region src/rules/no-unused-props.ts
const RULE_NAME$8 = "no-unused-props";
const RULE_FEATURES$7 = ["TSC", "EXP"];
var no_unused_props_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Warns component props that are defined but never used.",
			[Symbol.for("rule_features")]: RULE_FEATURES$7
		},
		messages: { noUnusedProps: "Prop `{{name}}` is declared but never used" },
		schema: []
	},
	name: RULE_NAME$8,
	create: create$8,
	defaultOptions: []
});
function create$8(context) {
	const services = ESLintUtils.getParserServices(context, false);
	const { ctx, listeners } = useComponentCollector(context);
	return {
		...listeners,
		"Program:exit"(program) {
			const checker = services.program.getTypeChecker();
			const components = ctx.getAllComponents(program);
			const totalDeclaredProps = /* @__PURE__ */ new Set();
			const totalUsedProps = /* @__PURE__ */ new Set();
			for (const [, component] of components) {
				const [props] = component.node.params;
				if (props == null) continue;
				const usedPropKeys = /* @__PURE__ */ new Set();
				if (!collectUsedPropKeysOfParameter(context, usedPropKeys, props)) continue;
				const tsNode = services.esTreeNodeToTSNodeMap.get(props);
				const declaredProps = checker.getTypeAtLocation(tsNode).getProperties();
				for (const declaredProp of declaredProps) {
					totalDeclaredProps.add(declaredProp);
					if (usedPropKeys.has(declaredProp.name)) totalUsedProps.add(declaredProp);
				}
			}
			const unusedProps = [...totalDeclaredProps].filter((x) => !totalUsedProps.has(x));
			for (const unusedProp of unusedProps) reportUnusedProp(context, services, unusedProp);
		}
	};
}
function collectUsedPropKeysOfParameter(context, usedPropKeys, parameter) {
	switch (parameter.type) {
		case AST_NODE_TYPES.Identifier: return collectUsedPropKeysOfIdentifier(context, usedPropKeys, parameter);
		case AST_NODE_TYPES.ObjectPattern: return collectUsedPropKeysOfObjectPattern(context, usedPropKeys, parameter);
		default: return false;
	}
}
function collectUsedPropKeysOfObjectPattern(context, usedPropKeys, objectPattern) {
	for (const property of objectPattern.properties) switch (property.type) {
		case AST_NODE_TYPES.Property: {
			const key = getKeyOfExpression(property.key);
			if (key == null) return false;
			usedPropKeys.add(key);
			break;
		}
		case AST_NODE_TYPES.RestElement:
			if (!collectUsedPropsOfRestElement(context, usedPropKeys, property)) return false;
			break;
	}
	return true;
}
function collectUsedPropsOfRestElement(context, usedPropKeys, restElement) {
	switch (restElement.argument.type) {
		case AST_NODE_TYPES.Identifier: return collectUsedPropKeysOfIdentifier(context, usedPropKeys, restElement.argument);
		default: return false;
	}
}
function collectUsedPropKeysOfIdentifier(context, usedPropKeys, identifier) {
	const variable = context.sourceCode.getScope(identifier).variables.find((v) => v.name === identifier.name);
	if (variable == null) return false;
	for (const ref of variable.references) {
		if (ref.identifier === identifier) continue;
		if (!collectUsedPropKeysOfReference(context, usedPropKeys, identifier, ref)) return false;
	}
	return true;
}
function collectUsedPropKeysOfReference(context, usedPropKeys, identifier, ref) {
	const { parent } = ref.identifier;
	switch (parent.type) {
		case AST_NODE_TYPES.MemberExpression:
			if (parent.object.type === AST_NODE_TYPES.Identifier && parent.object.name === identifier.name) {
				const key = getKeyOfExpression(parent.property);
				if (key == null) return false;
				usedPropKeys.add(key);
				return true;
			}
			break;
		case AST_NODE_TYPES.VariableDeclarator:
			if (parent.id.type === AST_NODE_TYPES.ObjectPattern && parent.init === ref.identifier) return collectUsedPropKeysOfObjectPattern(context, usedPropKeys, parent.id);
			break;
	}
	return false;
}
function getKeyOfExpression(expr) {
	switch (expr.type) {
		case AST_NODE_TYPES.Identifier: return expr.name;
		case AST_NODE_TYPES.Literal: if (typeof expr.value === "string") return expr.value;
	}
	return null;
}
function reportUnusedProp(context, services, prop) {
	const declaration = prop.getDeclarations()?.[0];
	if (declaration == null) return;
	const declarationNode = services.tsNodeToESTreeNodeMap.get(declaration);
	if (declarationNode == null) return;
	const nodeToReport = declarationNode.type === AST_NODE_TYPES.TSPropertySignature ? declarationNode.key : declarationNode;
	context.report({
		messageId: "noUnusedProps",
		node: nodeToReport,
		data: { name: prop.name }
	});
}

//#endregion
//#region src/rules/no-unused-state.ts
const RULE_NAME$7 = "no-unused-state";
const RULE_FEATURES$6 = [];
function isKeyLiteral(node, key) {
	return match(key).with({ type: AST_NODE_TYPES.Literal }, constTrue).with({
		type: AST_NODE_TYPES.TemplateLiteral,
		expressions: []
	}, constTrue).with({ type: AST_NODE_TYPES.Identifier }, () => !node.computed).otherwise(constFalse);
}
var no_unused_state_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Warns unused class component state.",
			[Symbol.for("rule_features")]: RULE_FEATURES$6
		},
		messages: { noUnusedState: "Unused class component state in '{{className}}'" },
		schema: []
	},
	name: RULE_NAME$7,
	create: create$7,
	defaultOptions: []
});
function create$7(context) {
	const classStack = [];
	const methodStack = [];
	const constructorStack = [];
	const stateDefs = /* @__PURE__ */ new WeakMap();
	function classEnter(node) {
		classStack.push(node);
	}
	function classExit() {
		const currentClass = classStack.pop();
		if (currentClass == null || !isClassComponent(currentClass)) return;
		const className = AST.getClassId(currentClass)?.name;
		const { node: defNode, isUsed = false } = stateDefs.get(currentClass) ?? {};
		if (defNode == null || isUsed) return;
		context.report({
			messageId: "noUnusedState",
			node: defNode,
			data: { className: className ?? "Component" }
		});
	}
	function methodEnter(node) {
		methodStack.push(node);
		const currentClass = classStack.at(-1);
		if (currentClass == null || !isClassComponent(currentClass)) return;
		if (node.static) {
			if (isGetDerivedStateFromProps(node) && isMatching({ params: [P.nonNullable, ...P.array()] })(node.value)) {
				const defNode = stateDefs.get(currentClass)?.node;
				stateDefs.set(currentClass, {
					node: defNode,
					isUsed: true
				});
			}
			return;
		}
		if (AST.getPropertyName(node.key) === "state") stateDefs.set(currentClass, {
			node: node.key,
			isUsed: false
		});
	}
	function methodExit() {
		methodStack.pop();
	}
	function constructorEnter(node) {
		constructorStack.push(node);
	}
	function constructorExit() {
		constructorStack.pop();
	}
	return {
		AssignmentExpression(node) {
			if (!isAssignmentToThisState(node)) return;
			const currentClass = classStack.at(-1);
			if (currentClass == null || !isClassComponent(currentClass)) return;
			const currentConstructor = constructorStack.at(-1);
			if (currentConstructor == null || !currentClass.body.body.includes(currentConstructor)) return;
			const isUsed = stateDefs.get(currentClass)?.isUsed ?? false;
			stateDefs.set(currentClass, {
				node: node.left,
				isUsed
			});
		},
		ClassDeclaration: classEnter,
		"ClassDeclaration:exit": classExit,
		ClassExpression: classEnter,
		"ClassExpression:exit": classExit,
		MemberExpression(node) {
			if (!AST.isThisExpression(node.object)) return;
			if (AST.getPropertyName(node.property) !== "state") return;
			const currentClass = classStack.at(-1);
			if (currentClass == null || !isClassComponent(currentClass)) return;
			const currentMethod = methodStack.at(-1);
			if (currentMethod == null || currentMethod.static) return;
			if (currentMethod === constructorStack.at(-1)) return;
			if (!currentClass.body.body.includes(currentMethod)) return;
			const defNode = stateDefs.get(currentClass)?.node;
			stateDefs.set(currentClass, {
				node: defNode,
				isUsed: true
			});
		},
		MethodDefinition: methodEnter,
		"MethodDefinition:exit": methodExit,
		"MethodDefinition[key.name='constructor']": constructorEnter,
		"MethodDefinition[key.name='constructor']:exit": constructorExit,
		PropertyDefinition: methodEnter,
		"PropertyDefinition:exit": methodExit,
		VariableDeclarator(node) {
			const currentClass = classStack.at(-1);
			if (currentClass == null || !isClassComponent(currentClass)) return;
			const currentMethod = methodStack.at(-1);
			if (currentMethod == null || currentMethod.static) return;
			if (currentMethod === constructorStack.at(-1)) return;
			if (!currentClass.body.body.includes(currentMethod)) return;
			if (node.init == null || !AST.isThisExpression(node.init) || node.id.type !== AST_NODE_TYPES.ObjectPattern) return;
			if (!node.id.properties.some((prop) => {
				if (prop.type === AST_NODE_TYPES.Property && isKeyLiteral(prop, prop.key)) return AST.getPropertyName(prop.key) === "state";
				return false;
			})) return;
			const defNode = stateDefs.get(currentClass)?.node;
			stateDefs.set(currentClass, {
				node: defNode,
				isUsed: true
			});
		}
	};
}

//#endregion
//#region src/rules/no-use-context.ts
const RULE_NAME$6 = "no-use-context";
const RULE_FEATURES$5 = ["MOD"];
var no_use_context_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Replaces usages of `useContext` with `use`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$5
		},
		fixable: "code",
		messages: { noUseContext: "In React 19, 'use' is preferred over 'useContext' because it is more flexible." },
		schema: []
	},
	name: RULE_NAME$6,
	create: create$6,
	defaultOptions: []
});
function create$6(context) {
	if (!context.sourceCode.text.includes("useContext")) return {};
	const settings$3 = getSettingsFromContext(context);
	if (compare(settings$3.version, "19.0.0", "<")) return {};
	const hookCalls = /* @__PURE__ */ new Set();
	return {
		CallExpression(node) {
			if (!isReactHookCall(node)) return;
			hookCalls.add(node);
		},
		ImportDeclaration(node) {
			if (node.source.value !== settings$3.importSource) return;
			const isUseImported = node.specifiers.some(isMatching({ local: {
				type: AST_NODE_TYPES.Identifier,
				name: "use"
			} }));
			for (const specifier of node.specifiers) {
				if (specifier.type !== AST_NODE_TYPES.ImportSpecifier) continue;
				if (specifier.imported.type !== AST_NODE_TYPES.Identifier) continue;
				if (specifier.imported.name === "useContext") context.report({
					messageId: "noUseContext",
					node: specifier,
					fix(fixer) {
						if (isUseImported) {
							const tokenBefore = context.sourceCode.getTokenBefore(specifier);
							return [
								fixer.remove(specifier),
								...tokenBefore?.value === "," ? [fixer.replaceTextRange([tokenBefore.range[1], specifier.range[0]], "")] : [],
								...getCorrelativeTokens(context, specifier).map((token) => fixer.remove(token))
							];
						}
						return fixer.replaceText(specifier.imported, "use");
					}
				});
			}
		},
		"Program:exit"() {
			for (const node of hookCalls) {
				if (!isUseContextCall(node)) continue;
				context.report({
					messageId: "noUseContext",
					node: node.callee,
					fix(fixer) {
						switch (node.callee.type) {
							case AST_NODE_TYPES.Identifier: return fixer.replaceText(node.callee, "use");
							case AST_NODE_TYPES.MemberExpression: return fixer.replaceText(node.callee.property, "use");
						}
						return null;
					}
				});
			}
		}
	};
}
function getCorrelativeTokens(context, node) {
	const tokenBefore = context.sourceCode.getTokenBefore(node);
	const tokenAfter = context.sourceCode.getTokenAfter(node);
	const tokens = [];
	if (tokenAfter?.value !== "," && tokenBefore?.value === ",") tokens.push(tokenBefore);
	if (tokenAfter?.value === ",") tokens.push(tokenAfter);
	return tokens;
}

//#endregion
//#region src/rules/no-useless-forward-ref.ts
const RULE_NAME$5 = "no-useless-forward-ref";
const RULE_FEATURES$4 = [];
var no_useless_forward_ref_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow useless `forwardRef` calls on components that don't use `ref`s.",
			[Symbol.for("rule_features")]: RULE_FEATURES$4
		},
		messages: { noUselessForwardRef: "A 'forwardRef' is used with this component but no 'ref' parameter is set." },
		schema: []
	},
	name: RULE_NAME$5,
	create: create$5,
	defaultOptions: []
});
function create$5(context) {
	return { CallExpression(node) {
		if (!isForwardRefCall(context, node)) return;
		const [component] = node.arguments;
		if (component == null || !AST.isFunction(component)) return;
		if (component.params[1] != null) return;
		context.report({
			messageId: "noUselessForwardRef",
			node: node.callee
		});
	} };
}

//#endregion
//#region src/rules/no-useless-fragment.ts
const RULE_NAME$4 = "no-useless-fragment";
const defaultOptions = [{ allowExpressions: true }];
var no_useless_fragment_default = createRule({
	meta: {
		type: "problem",
		defaultOptions: [...defaultOptions],
		docs: { description: "Disallow useless fragment elements." },
		fixable: "code",
		messages: { uselessFragment: "A fragment {{reason}} is useless." },
		schema: [{
			type: "object",
			additionalProperties: false,
			properties: { allowExpressions: {
				type: "boolean",
				description: "Allow fragments with a single expression child"
			} }
		}]
	},
	name: RULE_NAME$4,
	create: create$4,
	defaultOptions
});
function create$4(context, [option]) {
	const { allowExpressions = true } = option;
	return {
		JSXElement(node) {
			if (!isJsxFragmentElement(context, node)) return;
			checkNode(context, node, allowExpressions);
		},
		JSXFragment(node) {
			checkNode(context, node, allowExpressions);
		}
	};
}
/**
* Check if a Literal or JSXText node is whitespace
*/
function isWhiteSpace(node) {
	return typeof node.value === "string" && node.raw.trim() === "";
}
/**
* Check if a node is padding spaces (whitespace with line breaks)
*/
function isPaddingSpaces(node) {
	return isJsxText(node) && isWhiteSpace(node) && node.raw.includes("\n");
}
/**
* Trim whitespace like React would in JSX
*/
function trimLikeReact(text) {
	const leadingSpaces = /^\s*/.exec(text)?.[0] ?? "";
	const trailingSpaces = /\s*$/.exec(text)?.[0] ?? "";
	const start = leadingSpaces.includes("\n") ? leadingSpaces.length : 0;
	const end = trailingSpaces.includes("\n") ? text.length - trailingSpaces.length : text.length;
	return text.slice(start, end);
}
/**
* Check if a fragment node is useless and should be reported
*/
function checkNode(context, node, allowExpressions) {
	if (node.type === AST_NODE_TYPES.JSXElement && getJsxAttribute(context, node)("key") != null) return;
	if (isJsxHostElement(context, node.parent)) context.report({
		messageId: "uselessFragment",
		node,
		data: { reason: "placed inside a host component" },
		fix: getFix(context, node)
	});
	if (node.children.length === 0) {
		context.report({
			messageId: "uselessFragment",
			node,
			data: { reason: "contains less than two children" },
			fix: getFix(context, node)
		});
		return;
	}
	const isChildElement = AST.isOneOf([AST_NODE_TYPES.JSXElement, AST_NODE_TYPES.JSXFragment])(node.parent);
	switch (true) {
		case allowExpressions && !isChildElement && node.children.length === 1 && isJsxText(node.children.at(0)): return;
		case !allowExpressions && isChildElement:
			context.report({
				messageId: "uselessFragment",
				node,
				data: { reason: "contains less than two children" },
				fix: getFix(context, node)
			});
			return;
		case !allowExpressions && !isChildElement && node.children.length === 1:
			context.report({
				messageId: "uselessFragment",
				node,
				data: { reason: "contains less than two children" },
				fix: getFix(context, node)
			});
			return;
	}
	const nonPaddingChildren = node.children.filter((child) => !isPaddingSpaces(child));
	const firstNonPaddingChild = nonPaddingChildren.at(0);
	if (nonPaddingChildren.length === 0 || nonPaddingChildren.length === 1 && firstNonPaddingChild?.type !== AST_NODE_TYPES.JSXExpressionContainer) context.report({
		messageId: "uselessFragment",
		node,
		data: { reason: "contains less than two children" },
		fix: getFix(context, node)
	});
}
function getFix(context, node) {
	if (!canFix(context, node)) return null;
	return (fixer) => {
		const opener = node.type === AST_NODE_TYPES.JSXFragment ? node.openingFragment : node.openingElement;
		const closer = node.type === AST_NODE_TYPES.JSXFragment ? node.closingFragment : node.closingElement;
		const childrenText = opener.type === AST_NODE_TYPES.JSXOpeningElement && opener.selfClosing ? "" : context.sourceCode.getText().slice(opener.range[1], closer?.range[0]);
		return fixer.replaceText(node, trimLikeReact(childrenText));
	};
}
/**
* Check if it's safe to automatically fix the fragment
*/
function canFix(context, node) {
	if (node.parent.type === AST_NODE_TYPES.JSXElement || node.parent.type === AST_NODE_TYPES.JSXFragment) return isJsxHostElement(context, node.parent);
	if (node.children.length === 0) return false;
	return !node.children.some((child) => isJsxText(child) && !isWhiteSpace(child) || AST.is(AST_NODE_TYPES.JSXExpressionContainer)(child));
}

//#endregion
//#region src/rules/prefer-destructuring-assignment.ts
const RULE_NAME$3 = "prefer-destructuring-assignment";
const RULE_FEATURES$3 = [];
function isMemberExpressionWithObjectName(node) {
	return node.object.type === AST_NODE_TYPES.Identifier && "name" in node.object;
}
var prefer_destructuring_assignment_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces destructuring assignment for component props and context.",
			[Symbol.for("rule_features")]: RULE_FEATURES$3
		},
		messages: { preferDestructuringAssignment: "Use destructuring assignment for {{name}}." },
		schema: []
	},
	name: RULE_NAME$3,
	create: create$3,
	defaultOptions: []
});
function create$3(context) {
	const { ctx, listeners } = useComponentCollector(context);
	const memberExpressionWithNames = [];
	return {
		...listeners,
		MemberExpression(node) {
			if (isMemberExpressionWithObjectName(node)) {
				const scope = context.sourceCode.getScope(node);
				memberExpressionWithNames.push([scope, node]);
			}
		},
		"Program:exit"(program) {
			const components = [...ctx.getAllComponents(program).values()];
			function isFunctionComponent(block) {
				if (!AST.isFunction(block)) return false;
				const id = AST.getFunctionId(block);
				return id != null && isComponentNameLoose(id.name) && components.some((component) => component.node === block);
			}
			for (const [initialScope, memberExpression] of memberExpressionWithNames) {
				let scope = initialScope;
				let isComponent = isFunctionComponent(scope.block);
				while (!isComponent && scope.upper != null && scope.upper !== scope) {
					scope = scope.upper;
					isComponent = isFunctionComponent(scope.block);
				}
				if (!isComponent) continue;
				const component = scope.block;
				if (!("params" in component)) continue;
				const [props, ctx$1] = component.params;
				const isMatch = (node) => node != null && node.type === AST_NODE_TYPES.Identifier && node.name === memberExpression.object.name;
				if (isMatch(props)) context.report({
					messageId: "preferDestructuringAssignment",
					node: memberExpression,
					data: { name: "props" }
				});
				if (isMatch(ctx$1)) context.report({
					messageId: "preferDestructuringAssignment",
					node: memberExpression,
					data: { name: "context" }
				});
			}
		}
	};
}

//#endregion
//#region src/rules/prefer-namespace-import.ts
const RULE_NAME$2 = "prefer-namespace-import";
const RULE_FEATURES$2 = ["FIX"];
var prefer_namespace_import_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces React is imported via a namespace import.",
			[Symbol.for("rule_features")]: RULE_FEATURES$2
		},
		fixable: "code",
		messages: { preferNamespaceImport: "Prefer importing React as 'import * as React from \"{{importSource}}\"';" },
		schema: []
	},
	name: RULE_NAME$2,
	create: create$2,
	defaultOptions: []
});
function create$2(context) {
	const { importSource } = getSettingsFromContext(context);
	return { [`ImportDeclaration[source.value="${importSource}"] ImportDefaultSpecifier`](node) {
		const hasOtherSpecifiers = node.parent.specifiers.length > 1;
		context.report({
			messageId: "preferNamespaceImport",
			node: hasOtherSpecifiers ? node : node.parent,
			data: { importSource },
			fix(fixer) {
				const importDeclarationText = context.sourceCode.getText(node.parent);
				const semi = importDeclarationText.endsWith(";") ? ";" : "";
				const quote = node.parent.source.raw.at(0) ?? "'";
				const importStringPrefix = `import${node.parent.importKind === "type" ? " type" : ""}`;
				const importSourceQuoted = `${quote}${importSource}${quote}`;
				if (!hasOtherSpecifiers) return fixer.replaceText(node.parent, `${importStringPrefix} * as ${node.local.name} from ${importSourceQuoted}${semi}`);
				const specifiers = importDeclarationText.slice(importDeclarationText.indexOf("{"), importDeclarationText.indexOf("}") + 1);
				return fixer.replaceText(node.parent, [`${importStringPrefix} * as ${node.local.name} from ${importSourceQuoted}${semi}`, `${importStringPrefix} ${specifiers} from ${importSourceQuoted}${semi}`].join("\n"));
			}
		});
	} };
}

//#endregion
//#region src/rules/prefer-read-only-props.ts
const RULE_NAME$1 = "prefer-read-only-props";
const RULE_FEATURES$1 = ["TSC", "EXP"];
var prefer_read_only_props_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces read-only props in components.",
			[Symbol.for("rule_features")]: RULE_FEATURES$1
		},
		messages: { preferReadOnlyProps: "A function component's props should be read-only." },
		schema: []
	},
	name: RULE_NAME$1,
	create: create$1,
	defaultOptions: []
});
function create$1(context) {
	const services = ESLintUtils.getParserServices(context, false);
	const { ctx, listeners } = useComponentCollector(context);
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const [, component] of components) {
				if (component.id == null) continue;
				if (component.name == null) continue;
				const [props] = component.node.params;
				if (props == null) continue;
				const propsType = getConstrainedTypeAtLocation(services, props);
				if (isTypeReadonlyLoose(services, propsType)) continue;
				context.report({
					messageId: "preferReadOnlyProps",
					node: props
				});
			}
		}
	};
}
function isTypeReadonlyLoose(services, type) {
	if (isTypeReadonly(services.program, type)) return true;
	try {
		const im = getTypeImmutability(services.program, type);
		return isUnknown(im) || isImmutable(im) || isReadonlyShallow(im) || isReadonlyDeep(im);
	} catch {
		return true;
	}
}

//#endregion
//#region src/rules/prefer-use-state-lazy-initialization.ts
const RULE_NAME = "prefer-use-state-lazy-initialization";
const RULE_FEATURES = ["EXP"];
const ALLOW_LIST = [
	"Boolean",
	"String",
	"Number"
];
var prefer_use_state_lazy_initialization_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces function calls made inside `useState` to be wrapped in an `initializer function`.",
			[Symbol.for("rule_features")]: RULE_FEATURES
		},
		messages: { preferUseStateLazyInitialization: "To prevent re-computation, consider using lazy initial state for useState calls that involve function calls. Ex: 'useState(() => getValue())'." },
		schema: []
	},
	name: RULE_NAME,
	create,
	defaultOptions: []
});
function create(context) {
	return { CallExpression(node) {
		if (!isUseStateCall(node)) return;
		const [useStateInput] = node.arguments;
		if (useStateInput == null) return;
		for (const expr of AST.getNestedNewExpressions(useStateInput)) {
			if (!("name" in expr.callee)) continue;
			if (ALLOW_LIST.includes(expr.callee.name)) continue;
			if (AST.findParentNode(expr, isUseCall) != null) continue;
			context.report({
				messageId: "preferUseStateLazyInitialization",
				node: expr
			});
		}
		for (const expr of AST.getNestedCallExpressions(useStateInput)) {
			if (!("name" in expr.callee)) continue;
			if (isReactHookName(expr.callee.name)) continue;
			if (ALLOW_LIST.includes(expr.callee.name)) continue;
			if (AST.findParentNode(expr, isUseCall) != null) continue;
			context.report({
				messageId: "preferUseStateLazyInitialization",
				node: expr
			});
		}
	} };
}

//#endregion
//#region src/plugin.ts
const plugin = {
	meta: {
		name,
		version
	},
	rules: {
		"jsx-key-before-spread": jsx_key_before_spread_default,
		"jsx-no-comment-textnodes": jsx_no_comment_textnodes_default,
		"jsx-no-duplicate-props": jsx_no_duplicate_props_default,
		"jsx-no-iife": jsx_no_iife_default,
		"jsx-no-undef": jsx_no_undef_default,
		"jsx-shorthand-boolean": jsx_shorthand_boolean_default,
		"jsx-shorthand-fragment": jsx_shorthand_fragment_default,
		"jsx-uses-react": jsx_uses_react_default,
		"jsx-uses-vars": jsx_uses_vars_default,
		"no-access-state-in-setstate": no_access_state_in_setstate_default,
		"no-array-index-key": no_array_index_key_default,
		"no-children-count": no_children_count_default,
		"no-children-for-each": no_children_for_each_default,
		"no-children-map": no_children_map_default,
		"no-children-only": no_children_only_default,
		"no-children-prop": no_children_prop_default,
		"no-children-to-array": no_children_to_array_default,
		"no-class-component": no_class_component_default,
		"no-clone-element": no_clone_element_default,
		"no-component-will-mount": no_component_will_mount_default,
		"no-component-will-receive-props": no_component_will_receive_props_default,
		"no-component-will-update": no_component_will_update_default,
		"no-context-provider": no_context_provider_default,
		"no-create-ref": no_create_ref_default,
		"no-default-props": no_default_props_default,
		"no-direct-mutation-state": no_direct_mutation_state_default,
		"no-duplicate-key": no_duplicate_key_default,
		"no-forbidden-props": no_forbidden_props_default,
		"no-forward-ref": no_forward_ref_default,
		"no-implicit-key": no_implicit_key_default,
		"no-leaked-conditional-rendering": no_leaked_conditional_rendering_default,
		"no-missing-component-display-name": no_missing_component_display_name_default,
		"no-missing-context-display-name": no_missing_context_display_name_default,
		"no-missing-key": no_missing_key_default,
		"no-misused-capture-owner-stack": no_misused_capture_owner_stack_default,
		"no-nested-component-definitions": no_nested_component_definitions_default,
		"no-nested-lazy-component-declarations": no_nested_lazy_component_declarations_default,
		"no-prop-types": no_prop_types_default,
		"no-redundant-should-component-update": no_redundant_should_component_update_default,
		"no-set-state-in-component-did-mount": no_set_state_in_component_did_mount_default,
		"no-set-state-in-component-did-update": no_set_state_in_component_did_update_default,
		"no-set-state-in-component-will-update": no_set_state_in_component_will_update_default,
		"no-string-refs": no_string_refs_default,
		"no-unnecessary-key": no_unnecessary_key_default,
		"no-unnecessary-use-callback": no_unnecessary_use_callback_default,
		"no-unnecessary-use-memo": no_unnecessary_use_memo_default,
		"no-unnecessary-use-prefix": no_unnecessary_use_prefix_default,
		"no-unsafe-component-will-mount": no_unsafe_component_will_mount_default,
		"no-unsafe-component-will-receive-props": no_unsafe_component_will_receive_props_default,
		"no-unsafe-component-will-update": no_unsafe_component_will_update_default,
		"no-unstable-context-value": no_unstable_context_value_default,
		"no-unstable-default-props": no_unstable_default_props_default,
		"no-unused-class-component-members": no_unused_class_component_members_default,
		"no-unused-props": no_unused_props_default,
		"no-unused-state": no_unused_state_default,
		"no-use-context": no_use_context_default,
		"no-useless-forward-ref": no_useless_forward_ref_default,
		"no-useless-fragment": no_useless_fragment_default,
		"prefer-destructuring-assignment": prefer_destructuring_assignment_default,
		"prefer-namespace-import": prefer_namespace_import_default,
		"prefer-read-only-props": prefer_read_only_props_default,
		"prefer-use-state-lazy-initialization": prefer_use_state_lazy_initialization_default
	}
};

//#endregion
//#region src/index.ts
const { toFlatConfig } = getConfigAdapters("react-x", plugin);
var src_default = {
	...plugin,
	configs: {
		["recommended"]: toFlatConfig(recommended_exports),
		["recommended-type-checked"]: toFlatConfig(recommended_type_checked_exports),
		["recommended-typescript"]: toFlatConfig(recommended_typescript_exports)
	}
};

//#endregion
export { src_default as default };